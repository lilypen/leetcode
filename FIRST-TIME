4.
method 1: two pointors
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int med=(nums1.size()+nums2.size())/2,i=0,j=0,count=0;
        int num=0;
        double median;
        if((nums1.size()+nums2.size())%2==0)
        {
        while(i<nums1.size()&&j<nums2.size())
        {
            if(nums1[i]<nums2[j])
            {
                if(count==med-1)
                {
                    num=nums1[i];
                }
                if(count==med)
                {
                    num+=nums1[i];
                    break;
                }
                i++;
            }
            else 
            {
                if(count==med-1)
                {
                    num=nums2[j];
                }
                if(count==med)
                {
                    num+=nums2[j];
                    break;
                }
                j++;
            }
            count++;
            
        }
        while(i==nums1.size()&&j<nums2.size())
        {
            if(count==med-1)
                {
                    num=nums2[j];
                }
            if(count==med)
                {
                    num+=nums2[j];
                    break;
                }
                j++;
                count++;
        }
        while(i<nums1.size()&&j==nums2.size())
        {
            if(count==med-1)
                {
                    num=nums1[i];
                }
                if(count==med)
                {
                    num+=nums1[i];
                    break;
                }
                i++;
                count++;
        }
        median=(double)(num)/2;
            
        }
        else
        {
        while(i<nums1.size()&&j<nums2.size())
        {
            if(nums1[i]<nums2[j])
            {
                if(count==med)
                {
                    num=nums1[i];
                    break;
                }
                
                i++;
            }
            else 
            {
                if(count==med)
                {
                    num=nums2[j];
                    break;
                }
                
                j++;
            }
            count++;
            
        }
        while(i>=nums1.size()&&j<nums2.size())
        {
            if(count==med)
                {
                    num=nums2[j];
                    break;
                }
                
                j++;
                count++;
        }
        while(i<nums1.size()&&j>=nums2.size())
        {
            if(count==med)
                {
                    num=nums1[i];
                    break;
                }
                
                i++;
                count++;
        }
        median=num;
        }
        return median;
    }
};

method 2:merge first,sort.
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        nums1.insert(nums1.begin(),nums2.begin(),nums2.end());
        sort(nums1.begin(),nums1.end());
        double num;
        if(nums1.size()%2==0)
        {
            num=(double)(nums1[nums1.size()/2-1]+nums1[nums1.size()/2])/2;
        }
        else 
        {
            num=nums1[nums1.size()/2];
        }
        
        return num;
    }
};

method 3: find the k smallest number(iterative)
double findKth(int a[], int m, int b[], int n, int k)  
{  
    //always assume that m is equal or smaller than n  
    if (m > n)  
        return findKth(b, n, a, m, k);  
    if (m == 0)  
        return b[k - 1];  
    if (k == 1)  
        return min(a[0], b[0]);  
    //divide k into two parts  
    int pa = min(k / 2, m), pb = k - pa;  
    if (a[pa - 1] < b[pb - 1])  
        return findKth(a + pa, m - pa, b, n, k - pa);  
    else if (a[pa - 1] > b[pb - 1])  
        return findKth(a, m, b + pb, n - pb, k - pb);  
    else  
        return a[pa - 1];  
}  
  
class Solution  
{  
public:  
    double findMedianSortedArrays(int A[], int m, int B[], int n)  
    {  
        int total = m + n;  
        if (total & 0x1)  
            return findKth(A, m, B, n, total / 2 + 1);  
        else  
            return (findKth(A, m, B, n, total / 2)  
                    + findKth(A, m, B, n, total / 2 + 1)) / 2;  
    }  
};  



6.
class Solution {
public:
    string convert(string s, int numRows) {
       string res;
       string tmp[numRows];
       int n=numRows;
       int count=0,dir=0;//dir 0 represents +,1 represents -
       if(numRows==1)//or count will become -1
       {
           return s;
       }
       else
       {
       for(int i=0;i<s.size();i++)
       {
           if(dir==0)
           {               
               tmp[count].push_back(s[i]);
               if(count==n-1)
               {
                   dir=1;
                   count--;
               }
               else
               {
                   count++;

               }
           }
           else
           {
               //cout<<"0"<<endl;
               tmp[count].push_back(s[i]);
               if(count==0)
               {
                   dir=0;
                   count++;
               }
               else
               {
                   count--;
               }
           }
       }
       for(int i=0;i<n;i++)
       {
           res+=tmp[i];
       }
       
       return res;
       }
   }
};


9. Palindrome Number
class Solution {
public:
    bool isPalindrome(int x) {
        //if(x<0) x=-x;
        int sum=0,num=x;
        while(x>0)
        {
            sum=sum*10+x%10;
            x=x/10;
        }
        if(sum == num)//x is changed
        return true;
        else
        return false;
    }
};


12.
class Solution {
public:
    string intToRoman(int num) {
        string st[4][10]=
        {
          {"","I","II","III","IV","V","VI","VII","VIII","IX"},
          {"","X","XX","XXX","XL","L","LX","LXX","LXXX","XC"},
          {"","C","CC","CCC","CD","D","DC","DCC","DCCC","CM"},
          {"","M","MM","MMM"}
        };
        string s;
        
        s=s+(st[3][num/1000]);
        num=num%1000;
        s+=(st[2][num/100]);
        num=num%100;
        s+=(st[1][num/10]);
        num=num%10;
        s+=(st[0][num/1]);
        return s;
        
    }
};


13.
class Solution {
public:
    int romanToInt(string s) {
        int res=0;
        for(int i=s.size()-1;i>=0;i--)
        {
            switch(s[i])
            {
            case 'I':res+=(res>=5?-1:1);break;
            case 'V':res+=5;break;
            case 'X':res+=(res>=50?-10:10);break;
            case 'L':res+=50;break;
            case 'C':res+=(res>=500?-100:100);break;
            case 'D':res+=500;break;
            case 'M':res+=1000;break;
            }
        }
        return res;
    }
};


14.
method:string
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        
        if(strs.size()==0)
        return "";
        else
        {
            string res=strs[0];
       
        for(int i=1;i<strs.size();i++)
        {
            int j;
            for(j=0;j<strs[i].size();j++)
            {
                if(strs[i][j]!=res[j])
                {
                    res.erase(res.begin()+j,res.end());
                    break;
                }
            }
            res.erase(res.begin()+j,res.end());//strs[i] is shortter than res
        }
        return res;
        }
    }
};


21. Merge Two Sorted Lists 
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(!l1) return l2;
        if(!l2) return l1;
        ListNode* res=new ListNode(INT_MIN);
        ListNode* pre=res,*post=l1;
        res->next=l1;
        while(l2)
        {
            if(l2->val>=pre->val&&l2->val<=post->val)
            {
                ListNode* tmp=l2->next;
                pre->next=l2;
                l2->next=post;
                l2=tmp;
                pre=pre->next;
            }
            else
            {
            pre=pre->next;
            post=post->next;
            }
            if(post==NULL)
            {
                pre->next=l2;
                break;
            }
        }
        return res->next;
    }
};

24. Swap Nodes in Pairs
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head==NULL||head->next==NULL)
        return head;
        ListNode* pre=head,* ppre=head,*post=head->next;
        head=head->next;
        while(pre&&post)
        {
            if(ppre!=pre)
            ppre->next=post;
            pre->next=post->next;
            post->next=pre;
            ppre=pre;
            pre=pre->next;
            if(pre)
            {
            post=pre->next;
            }
            else 
            {
            post=NULL;
            }
        }
        
        return head;
        
    }
};


25. Reverse Nodes in k-Group
my method
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(head==NULL) return head;
        ListNode* post=head,*pre=head->next,*ppre=head,*newhead=new ListNode(0),*pppre=newhead;
        newhead->next=head;
        while(post)
        {
            int count=0;
            while(count++!=k)
            {
                if(post==NULL)
                return newhead->next;
                post=post->next;
            }
            ppre->next=post;
            ListNode* f=ppre;
            while(pre!=post)
            {
                ListNode* tmp=pre->next;
                pre->next=ppre;
                ppre=pre;
                pre=tmp;
            }
            pppre->next=ppre;
            pppre=f;
            if(post&&post->next)
            {
            pre=post->next;
            ppre=post;
            }
            else
            return newhead->next;
        }
        return newhead->next;
    }
};


29. Divide Two Integers
method:bit manipulation
In this problem, we are asked to divide two integers. However, we are not allowed to use division, multiplication and mod operations. So, what else can we use? Yeah, bit manipulations.

Let's do an example and see how bit manipulations work.

Suppose we want to divide 15 by 3, so 15 is dividend and 3 is divisor. Well, division simply requires us to find how many times we can subtract the divisor from the the dividend without making the dividend negative.

Let's get started. We subtract 3 from 15 and we get 12, which is positive. Let's try to subtract more. Well, we shift 3 to the left by 1 bit and we get 6. Subtracting 6 from 15 still gives a positive result. Well, we shift again and get 12. We subtract 12 from 15 and it is still positive. We shift again, obtaining 24 and we know we can at most subtract 12. Well, since 12 is obtained by shifting 3 to left twice, we know it is 4 times of 3. How do we obtain this 4? Well, we start from 1 and shift it to left twice at the same time. We add 4 to an answer (initialized to be 0). In fact, the above process is like 15 = 3 * 4 + 3. We now get part of the quotient (4), with a remainder 3.

Then we repeat the above process again. We subtract divisor = 3 from the remaining dividend = 3 and obtain 0. We know we are done. No shift happens, so we simply add 1 << 0 to the answer.

Now we have the full algorithm to perform division.

According to the problem statement, we need to handle some exceptions, such as overflow.

Well, two cases may cause overflow:

divisor = 0;
dividend = INT_MIN and divisor = -1 (because abs(INT_MIN) = INT_MAX + 1).
Of course, we also need to take the sign into considerations, which is relatively easy.

class Solution {
public:
    int divide(int dividend, int divisor) {
        if(divisor==0||(dividend==INT_MIN&&divisor==-1)) return INT_MAX;
        int sign=((dividend<0)^(divisor<0))?-1:1;
        long dvd=labs(dividend);
        long dvs=labs(divisor);
        int res=0;
        while(dvd>=dvs)
        {
            long tmp=dvs,multiple=1;//用long不用int
            while(dvd>=(tmp<<1))
            {
                tmp<<=1;
                multiple<<=1;
            }
            dvd-=tmp;
            res+=multiple;
        }
        return sign==1?res:-res;
    }
};



39.
class Solution {
public:
    std::vector<std::vector<int> > combinationSum(std::vector<int> &candidates, int target) {
        std::sort(candidates.begin(), candidates.end());
        std::vector<std::vector<int> > res;
        std::vector<int> combination;
        combinationSum(candidates, target, res, combination, 0);
        return res;
    }
private:
    void combinationSum(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {
        if  (!target) {
            res.push_back(combination);
            return;
        }
        for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i) {
            combination.push_back(candidates[i]);
            combinationSum(candidates, target - candidates[i], res, combination, i);
            combination.pop_back();
        }
    }
};

40.
class Solution {
public:
    void backtrack(vector<vector<int>>& res,vector<int> candidates,vector<int> combination,int target,int begin)
    {
        if(!target)
        {
            
            res.push_back(combination);
        }
        else if(target>0)//\B2\BBָ\C3\F7target>0\B3\ACʱ
        {
        for(int i=begin;i<candidates.size();i++)
        {
            combination.push_back(candidates[i]);
            backtrack(res,candidates,combination,target-candidates[i],i+1);
            combination.pop_back();
        }
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<vector<int>> res;
        sort(candidates.begin(),candidates.end());
        int i;
        for(i=0;i<candidates.size();i++)//\B3\ACʱ
        {
            if(candidates[i]>target)
            {
                break;
            }
        }
        candidates.erase(candidates.begin()+i,candidates.end());
        backtrack(res,candidates,{},target,0);
        sort(res.begin(),res.end());
        vector<vector<int>>::iterator it=unique(res.begin(),res.end());
        res.erase(it,res.end());
        return res;
         
    }
};



42. Trapping Rain Water
my method 1:stack
class Solution {
public:
    int trap(vector<int>& height) {
        stack<int> s;
        int size=height.size();
        if(size<=2) return 0;
        int back=0,sum=0;
        for(int i=0;i<size;i++)
        {
            //cout<<i<<endl;
            if(s.empty())
            {
                
                if(height[i]!=0)
                {
                s.push(i);
                back=i;
                //cout<<i<<endl;
                }
            }
            else if(height[i]<height[back])
            {
                s.push(i);
            }
            else
            {
                while(!s.empty())
                {
                    int tmp=s.top();
                    s.pop();
                    if(height[back]-height[tmp]>0) sum+=height[back]-height[tmp];
                    cout<<height[back]-height[tmp]<<",";
                }
                s.push(i);
                back=i;
                //cout<<i<<",";
            }
            
        }
        if(s.size()>2)//反向再来一次
        {
        while(!s.empty()) s.pop();
       // cout<<1<<endl;
        for(int i=size-1;i>=0;i--)
        {
            if(s.empty())
            {
                if(height[i]!=0)
                {
                s.push(i);
                back=i;
                }
            }
            else if(height[i]<=height[back])//相等的情况前面算过了
            {
                s.push(i);
                //cout<<i;
            }
            else
            {
                while(!s.empty())
                {
                    int tmp=s.top();
                    s.pop();
                    if(height[back]-height[tmp]>0) sum+=height[back]-height[tmp];
                    //cout<<tmp;
                }
                s.push(i);
                back=i;
            }
            
        }
        }
        return sum;
        
    }
};

stack 的另一个method 不太懂
class Solution {
public:
    int trap(vector<int>& height) {
        stack<int> s;
        int max_water(0);
        int i(0);
        while (i<height.size()) {
            if (s.empty()||height[i]<=height[s.top()]) {
                s.push(i++);
            } else {
                int bot=height[s.top()];
                s.pop();
                max_water+=s.empty()?0:((min(height[i],height[s.top()])-bot)*(i-s.top()-1));
            }
        }
        return max_water;
    }
};


method 2:two pointers
Here is my idea: instead of calculating area by height*width, we can think it in a cumulative way. In other words, sum water amount of each bin(width=1).
Search from left to right and maintain a max height of left and right separately, which is like a one-side wall of partial container. Fix the higher one and flow water from the lower part. For example, if current height of left is lower, we fill water in the left bin. Until left meets right, we filled the whole container.

class Solution {
public:
    int trap(int A[], int n) {
        int left=0; int right=n-1;
        int res=0;
        int maxleft=0, maxright=0;
        while(left<=right){
            if(A[left]<=A[right]){
                if(A[left]>=maxleft) maxleft=A[left];
                else res+=maxleft-A[left];
                left++;
            }
            else{
                if(A[right]>=maxright) maxright= A[right];
                else res+=maxright-A[right];
                right--;
            }
        }
        return res;
    }
};



61. Rotate List
my method:
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        ListNode* slow=head,*fast=head,*preslow=head,*prefast;
        int len=0;
        while(fast!=NULL) 
        {
            fast=fast->next;
            len++;
        }
        if(len==0||k%len==0) return head;//if len=0,then k%len will WTE
        k=k%len;
        fast=head;
        while(k--!=0&&fast!=NULL) fast=fast->next;
        while(fast!=NULL)
        {
            preslow=slow;
            slow=slow->next;
            prefast=fast;
            fast=fast->next;
        }
        preslow->next=NULL;
        prefast->next=head;
        return slow;
        
        
    }
};




71. Simplify Path
method: stack
重复连续出现的'/'，只按1个处理，即跳过重复连续出现的'/'；
如果路径名是"."，则不处理；
如果路径名是".."，则需要弹栈，如果栈为空，则不做处理；
如果路径名为其他字符串，入栈。
class Solution {
public:
    string simplifyPath(string path) {
        stack<string> s,copys;
        int i=0;
        while(i!=path.size())
        {
            while(i!=path.size()&&path[i]=='/') i++;
            if(i==path.size()) break;
            int start=i;
            while(i!=path.size()&&path[i]!='/') i++;
            string str=path.substr(start,i-start);
            if(!s.empty()&&str=="..") s.pop();
            if(str!="."&&str!="..") s.push(str);
        }
        string res;
        while(!s.empty())
        {
            copys.push(s.top());
            s.pop();
        }
        while(!copys.empty())//can just use vector
        {
            res+="/"+copys.top();
            copys.pop();
        }
        if(res.size()==0) return "/";
        return res;
    }
};

method 2:C++ also have getline which acts like Java's split.!!!
string simplifyPath(string path) {
    string res, tmp;
    vector<string> stk;
    stringstream ss(path);
    while(getline(ss,tmp,'/')) {
        if (tmp == "" or tmp == ".") continue;
        if (tmp == ".." and !stk.empty()) stk.pop_back();
        else if (tmp != "..") stk.push_back(tmp);
    }
    for(auto str : stk) res += "/"+str;
    return res.empty() ? "/" : res;
} 

75. sort colours
method 1 :First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.
class Solution {
public:
    void sortColors(vector<int>& nums) {
        vector<int> res;
        int count1=0,count2=0,count3=0;
        for(int i=0;i<nums.size();i++)
        {
            if(nums[i]==0)
            count1++;
             if(nums[i]==1)
            count2++;
             if(nums[i]==2)
            count3++;
        }
        for(int i=0;i<count1;i++)
        {
            nums[i]=0;
        }
        for(int i=count1;i<count1+count2;i++)
        {
            nums[i]=1;
        }
        for(int i=count1+count2;i<count1+count2+count3;i++)
        {
            nums[i]=2;
        }
        

    }
};

method 2: one-pass, swap
class Solution {
public:
    void sortColors(vector<int>& nums) {
        vector<int> res;
        int end=nums.size()-1,begin=0;
        for(int i=0;i<nums.size();i++)
        {
            while(nums[i]==2&&i<end)//note while and i<end. i>begin
            swap(nums[i],nums[end--]);
            while(nums[i]==0&&i>begin)
            swap(nums[i],nums[begin++]);
            
            
        }
       
        

    }
};


82.
my method 1
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head) return head;
        ListNode* newhead=new ListNode(INT_MIN),*pre=newhead,*post=head;
        int tmp;
        newhead->next=head;
        while(post->next)
        {
            if(post->next->val==post->val)
            {
                tmp=post->val;
            }
            if(post->val==tmp)
            {
                pre->next=post->next;
                post=post->next;
            }
            else
            {
                pre=pre->next;
                post=post->next;
            }
        }
        if(post->val==tmp)
        pre->next=post->next;
        return newhead->next;
    }
};
method 2 i can't understand; recursive
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (!head) return 0;
        if (!head->next) return head;
        
        int val = head->val;
        ListNode* p = head->next;
        
        if (p->val != val) {
            head->next = deleteDuplicates(p);
            return head;
        } else {
            while (p && p->val == val) p = p->next;
            return deleteDuplicates(p);
        }
    }
};

86.
my method 1: delete and insert to another list 
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        if(!head||!head->next) return head;
        ListNode*new_head=new ListNode(0),* pre=new_head,*post=head,*res=NULL,*cur=res;
        new_head->next=head;
        while(post)
        {
            if(post->val<x)
            {
                if(res==NULL)
                {
                    res=post;
                }
                else
                cur->next=post;
                if(post==head)
                head=post->next;
                cur=post;
                ListNode* tmp=post->next;
                post->next=NULL;
                pre->next=tmp;
                post=tmp;
            }
            else
            {
                pre=pre->next;
                post=post->next;
                //cout<<post->val;
            }
        }
        if(cur)
        {
        cur->next=head;
        return res;
        }
        else
        return head;
        
        
    }
};

method 2  just apend after two list;
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode* p1=new ListNode(0),*p2=new ListNode(0),*pre=p1,*post=p2;
        
        while(head)
        {
          if(head->val<x)
          {
              pre->next=head;
              pre=pre->next;
          }
          else
          {
              post->next=head;
              post=post->next;
          }
          head=head->next;
          
        }
        post->next=NULL;
        pre->next=p2->next;
        return p1->next;
        
        
    }
};

92. Reverse Linked List II
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        ListNode* ppre=head,*pre=head,*post=head;
        int count=1;
        while(post)
        {
            if(count==m-1)
            {
                ppre=post;
                post=post->next;
            }
            else if(count>m&&count<=n)
            {
                ListNode *tmp=post->next;
                post->next=pre;
                pre=post;
                post=tmp;
                if(count==n)
                {
                    
                    if(m==1)
                    {
                    ppre->next=post;
                    head=pre;
                    
                    }
                    else
                    {
                    ppre->next->next=post;
                    ppre->next=pre;
                    }
                    
                }
                
            }
            else
            {
            pre=post;
            post=post->next;
            }
            count++;
            
        }
        return head;
    }
};

method 2:
ListNode *reverseBetween(ListNode *head, int m, int n) {
    if(m==n)return head;
	n-=m;
    ListNode prehead(0);
    prehead.next=head;
    ListNode* pre=&prehead;
    while(--m)pre=pre->next;        
    ListNode* pstart=pre->next;
    while(n--)
    {
        ListNode *p=pstart->next;
        pstart->next=p->next;
        p->next=pre->next;
        pre->next=p;
    }
    return prehead.next;
}

94. Binary Tree Inorder Traversal
my method 1:
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
   void inorderTraversal(TreeNode* root,vector<int> &res)
   {
       if(root==NULL) return;
       inorderTraversal(root->left,res);
       res.push_back(root->val);
       inorderTraversal(root->right,res);
       
   }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
         inorderTraversal(root,res);
         return res;
    }
};

my method 2:
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
   
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;
        while(root)
        {
            while(root)
            {
                st.push(root);
                root=root->left;
            }
            root=st.top();
            while(root&&root->right==NULL&&!st.empty())
            {
                
            res.push_back(root->val);
            st.pop();
            if(!st.empty()) root=st.top();
            else root=NULL;
            }
            if(root)
            {
            res.push_back(root->val);
            st.pop();
            root=root->right;
            }
        }
        return res;
    }
};

100. Same Tree
my method
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p==NULL&&q==NULL)
        return true;
        if((!p&&q)||(!q&&p)||p->val!=q->val)
        return false;
        return (isSameTree(p->left,q->left)&&isSameTree(p->right,q->right));
    }
};


104. Maximum Depth of Binary Tree
method 1:Depth-first-search
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        int leftheight,rightheight;
        if(root==NULL)
        {
            return 0;
        }
        leftheight=maxDepth(root->left);
        rightheight=maxDepth(root->right);
        return leftheight>rightheight?leftheight+1:rightheight+1;
    }
};

method 2:Breadth-first-search
int maxDepth(TreeNode *root)
{
    if(root == NULL)
        return 0;
    
    int res = 0;
    queue<TreeNode *> q;
    q.push(root);
    while(!q.empty())
    {
        ++ res;
        for(int i = 0, n = q.size(); i < n; ++ i)
        {
            TreeNode *p = q.front();
            q.pop();
            
            if(p -> left != NULL)
                q.push(p -> left);
            if(p -> right != NULL)
                q.push(p -> right);
        }
    }
    
    return res;
}



127. Word Ladder
method:bfs;像这种求最短路径、树最小深度问题bfs最适合(类似于层序遍历二叉树，找到最先遍历到的叶子的层数就是树的最小高度)
class Solution {
public:
    int ladderLength(string beginWord, string endWord, unordered_set<string>& wordList) {
        queue<string> tovisit;
        tovisit.push(beginWord);
        int dist=1;
        while(!tovisit.empty())
        {
            int size=tovisit.size();
            for(int i=0;i<size;i++)
            {
                string word=tovisit.front();
                tovisit.pop();
                if(word==endWord) return dist;
                addNext(word,wordList,tovisit);
            }
            dist++;
        }
        return 0;
    }
    void addNext(string word,unordered_set<string>& wordList,queue<string> &tovisit)
    {
        wordList.erase(word);
        for(int j=0;j<word.size();j++)
        {
            char c=word[j];
            for(int k=0;k<26;k++)
            {
                word[j]='a'+k;
                if(wordList.find(word)!=wordList.end()) 
                {
                    tovisit.push(word);
                    wordList.erase(word);
                }
            }
            word[j]=c;
        }
        
    }
};




130. Surrounded Regions
my method :dfs
First, check the four border of the matrix. If there is a element is
'O', alter it and all its neighbor 'O' elements to '1'.
Then ,alter all the 'O' to 'X'
At last,alter all the '1' to 'O'

class Solution {
public:
    void solve(vector<vector<char>>& board) {
        if(board.size()==0) return;
        int n=board.size(),m=board[0].size();
        
        
        for(int i=0;i<n;i++)
        {
            if(board[i][0]=='O')
            {
                dfs(board,i,0,n,m);
            }
            if(board[i][m-1]=='O')
            {
                dfs(board,i,m-1,n,m);
            }
        }
        for(int j=1;j<m-1;j++)
        {
            if(board[0][j]=='O')
            {
                dfs(board,0,j,n,m);
            }
            if(board[n-1][j]=='O')
                dfs(board,n-1,j,n,m);
        }
        for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
        {
            //cout<<hs[i][j];
            if(board[i][j]=='T')
            board[i][j]='O';
            else
            board[i][j]='X';
            
        }
    }
    void dfs(vector<vector<char>> &board,int i,int j,int n,int m)
    {
        if(board[i][j]=='O')
        {
            board[i][j]='T';
            if(i>1) dfs(board,i-1,j,n,m);//shoud be 1 because of the case OOOOOOOOOO XXXXXXXXXO OOOOOOOOOO OXXXXXXXXX OOOOOOOOOO stack overflow;bfs is                           //better
            if(i<n-1) dfs(board,i+1,j,n,m);
            if(j>1) dfs(board,i,j-1,n,m);
            if(j<m-1) dfs(board,i,j+1,n,m);
        }
        
        
        
    }
};


method 2:bfs
void bfsBoundary(vector<vector<char> >& board, int w, int l)
{
    int width = board.size();
    int length = board[0].size();
    deque<pair<int, int> > q;
    q.push_back(make_pair(w, l));
    board[w][l] = 'B';
    while (!q.empty()) {
        pair<int, int> cur = q.front();
        q.pop_front();
        pair<int, int> adjs[4] = {{cur.first-1, cur.second}, 
            {cur.first+1, cur.second}, 
            {cur.first, cur.second-1},
            {cur.first, cur.second+1}};
        for (int i = 0; i < 4; ++i)
        {
            int adjW = adjs[i].first;
            int adjL = adjs[i].second;
            if ((adjW >= 0) && (adjW < width) && (adjL >= 0)
                    && (adjL < length) 
                    && (board[adjW][adjL] == 'O')) {
                q.push_back(make_pair(adjW, adjL));
                board[adjW][adjL] = 'B';
            }
        }
    }
}

void solve(vector<vector<char> > &board) {
    int width = board.size();
    if (width == 0) //Add this to prevent run-time error!
        return;
    int length = board[0].size();
    if  (length == 0) // Add this to prevent run-time error!
        return;

    for (int i = 0; i < length; ++i)
    {
        if (board[0][i] == 'O')
            bfsBoundary(board, 0, i);

        if (board[width-1][i] == 'O')
            bfsBoundary(board, width-1, i);
    }

    for (int i = 0; i < width; ++i)
    {
        if (board[i][0] == 'O')
            bfsBoundary(board, i, 0);
        if (board[i][length-1] == 'O')
            bfsBoundary(board, i, length-1);
    }

    for (int i = 0; i < width; ++i)
    {
        for (int j = 0; j < length; ++j)
        {
            if (board[i][j] == 'O')
                board[i][j] = 'X';
            else if (board[i][j] == 'B')
                board[i][j] = 'O';
        }
    }
}




136. Single Number
method 1 :sort
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        map<int,int> hs;
        int i;
        for(i=1;i<nums.size();i=i+2)
        {
            if(nums[i]!=nums[i-1])
            {
                break;
                
            }
        }
        return nums[i-1];
    }
};

method 2 :bit manipulation
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res=0;
        for(int i=0;i<nums.size();i++)
        {
            res=res^nums[i];
        }
        return res;
    }
};

141. Linked List Cycle
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        //if(!head) return false;
        ListNode* fast=head,*slow=new ListNode(0);
        slow->next=head;
        while(fast&&fast->next)
        {
            if(fast==slow)
            return true;
            fast=fast->next->next;
            slow=slow->next;
        }
        return false;
    }
};

142. Linked List Cycle II
Alogrithm Description:
Step 1: Determine whether there is a cycle

1.1) Using a slow pointer that move forward 1 step each time

1.2) Using a fast pointer that move forward 2 steps each time

1.3) If the slow pointer and fast pointer both point to the same location after several moving steps, there is a cycle;

1.4) Otherwise, if (fast->next == NULL || fast->next->next == NULL), there has no cycle.

Step 2: If there is a cycle, return the entry location of the cycle

2.1) L1 is defined as the distance between the head point and entry point

2.2) L2 is defined as the distance between the entry point and the meeting point

2.3) C is defined as the length of the cycle

2.4) n is defined as the travel times of the fast pointer around the cycle When the first encounter of the slow pointer and the fast pointer

According to the definition of L1, L2 and C, we can obtain:

the total distance of the slow pointer traveled when encounter is L1 + L2

the total distance of the fast pointer traveled when encounter is L1 + L2 + n * C

Because the total distance the fast pointer traveled is twice as the slow pointer, Thus:

2 * (L1+L2) = L1 + L2 + n * C => L1 + L2 = n * C => L1 = (n - 1) C + (C - L2)*

It can be concluded that the distance between the head location and entry location is equal to the distance between the meeting location and the entry location along the direction of forward movement.

So, when the slow pointer and the fast pointer encounter in the cycle, we can define a pointer "entry" that point to the head, this "entry" pointer moves one step each time so as the slow pointer. When this "entry" pointer and the slow pointer both point to the same location, this location is the node where the cycle begins.

method:
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
         if (head == NULL || head->next == NULL)
        return NULL;
        ListNode* fast=head,*slow=head,*entry=head;
        while(fast->next&&fast->next->next)
        {
            fast=fast->next->next;
            slow=slow->next;
            if(fast==slow)
            {
                while(entry!=slow)
                {
                    slow=slow->next;
                    entry=entry->next;
                }
                return entry;
            }
           
        }
        return NULL;
    }
};


144.
method 1: recursive
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res={};
        preorderTraversal(root,res);
        return res;
    }
    void preorderTraversal(TreeNode* root,vector<int> &res) {
        if(root==NULL) return;//can't return res,maybe right is not null
        res.push_back(root->val);
        preorderTraversal(root->left,res);
        preorderTraversal(root->right,res);
    }
};

method 2: stack
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res={};
        stack<TreeNode*> st;
        
        while(root)
        {
            while(root)
            {
                st.push(root);
                res.push_back(root->val);
                root=root->left;
            }
            while((!st.empty())&&st.top()->right==NULL)
            {
                st.pop();
                
            }
            if(st.empty()) return res;
            root=st.top()->right;
            st.pop();
            
        }
        return res;
    }

};

147. Insertion Sort List
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        if(head==NULL) return head;
        ListNode* res=new ListNode(INT_MIN);
        res->next=head;
        head=head->next;
        res->next->next=NULL;
        while(head)
        {
            ListNode* tmp=head->next;
            ListNode* pre=res,*post=res->next;
            while(post)
            {
               if(head->val>=pre->val&&head->val<=post->val)
                {
                    head->next=post;
                    pre->next=head;
                    break;
                }
                pre=pre->next;
                post=post->next;
            }
            if(post==NULL)
            {
                pre->next=head;
                head->next=NULL;
            }
            head=tmp;
        }
        return res->next;
    }
};



151. Reverse Words in a String
method:o(1) space ;First, reverse the whole string, then reverse each word. another method is to use stack but not o(1) space

class Solution {
public:

    void reverseWords(string &s) {
        reverse(s.begin(),s.end());
        int storeIndex=0;
        for(int i=0;i<s.size();i++)
        {
            if(s[i]!=' ')
            {
                if(storeIndex!=0) s[storeIndex++]=' ';
                int end=i;
                while(end<s.size()&&s[end]!=' ') s[storeIndex++]=s[end++];
                reverse(s.begin()+storeIndex-(end-i),s.begin()+storeIndex);
                i=end;
            }
        }
        s.erase(s.begin()+storeIndex,s.end());
    }
};




160. 
my method 1:
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* a=headA,* b=headB;
        int counta=0,countb=0;
        while(a)//the size of two list
        {
            counta++;
            a=a->next;
        }
        while(b)
        {
            countb++;
            b=b->next;
        }
        int tmp=counta-countb>0?counta-countb:countb-counta;
        ListNode* min=counta-countb>0?headB:headA;
        ListNode* max=counta-countb>0?headA:headB;
        for(int i=0;i<tmp;i++)
        {
            max=max->next;
        }
        while(min)
        {
            if(min==max)
            {
            return min;
            }
            min=min->next;
            max=max->next;
        }
        return NULL;
    }
};

method 2: 
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) 
{
    ListNode *p1 = headA;
    ListNode *p2 = headB;
        
    if (p1 == NULL || p2 == NULL) return NULL;

    while (p1 != NULL && p2 != NULL && p1 != p2) {
        p1 = p1->next;
        p2 = p2->next;

        //
        // Any time they collide or reach end together without colliding 
        // then return any one of the pointers.
        //
        if (p1 == p2) return p1;

        //
        // If one of them reaches the end earlier then reuse it 
        // by moving it to the beginning of other list.
        // Once both of them go through reassigning, 
        // they will be equidistant from the collision point.
        //
        if (p1 == NULL) p1 = headB;
        if (p2 == NULL) p2 = headA;
    }
        
    return p1;
}



165. Compare Version Numbers
method:
class Solution {
public:
    int compareVersion(string version1, string version2) {
        int i = 0; 
        int j = 0;
    int n1 = version1.size(); 
    int n2 = version2.size();
    
    int num1 = 0;
    int num2 = 0;
    while(i<n1 || j<n2)
    {
        while(i<n1 && version1[i]!='.'){
            num1 = num1*10+(version1[i]-'0');
            i++;
        }
        
        while(j<n2 && version2[j]!='.'){
            num2 = num2*10+(version2[j]-'0');
            j++;
        }
        
        if(num1>num2) return 1;
        else if(num1 < num2) return -1;
        
        num1 = 0;
        num2 = 0;
        i++;
        j++;
    }
    
    return 0;
    }
};



166. Fraction to Recurring Decimal
method:
难点：如何识别循环体？

解决方法：用一个HashMap记录每一个余数，当出现重复的余数时，那么将会进入循环，两个重复余数之间的部分就是循环体。

示例：1/13=0.076923076923076923...，当小数部分第二次出现0时，就意味着开始了循环，那么需要把076923用括号括起来，结果为0.(076923)。

涉及技巧：1）在不断相除的过程中，把余数乘以10再进行下一次相除，保证一直是整数相除；2）HashMap的key和value分别是<当前余数, 对应结果下标>，这样获取076923时就可根据value值来找。

注意点1：考虑正负数，先判断符号，然后都转化为正数；

注意点2：考虑溢出，如果输入为Integer.MIN_VALUE，取绝对值后会溢出。

class Solution {
public:
    string fractionToDecimal(int numerator, int denominator) {
        if(denominator==0) return "";
        if(numerator==0) return "0";//not -0
        
        string res;
        if(numerator<0^denominator<0) res+="-";
        
        long n=labs(numerator);//avoid INT_MIN to flow
        long d=labs(denominator);
        
        res+=to_string(n/d);
        long r=n%d;
        if(r==0) return res;
        
        res+=".";
        map<long,int> hs;
        while(r!=0)
        {
            if(hs.find(r)!=hs.end())
            {
                res.insert(hs[r],1,'(');
                res+=")";
                return res;
            }
            
            hs[r]=res.size();
            r*=10;
            res+=to_string(r/d);
            r=r%d;
            
        }
        return res;
    }
};


179. Largest Number
method:
排序（Sort）

排序思路：对于两个备选数字a和b，如果str(a) + str(b) > str(b) + str(a)，则a在b之前，否则b在a之前

按照此原则对原数组从大到小排序即可
class Solution {
public:
    string largestNumber(vector<int>& nums) {
        sort(nums.begin(),nums.end(),cmp);
        string res;
        for(int i:nums)
        {
            res+=to_string(i);
        }
        if(res.size()>1&&res[0]=='0') res="0";//{0,0}
        return res;
    }
    static bool cmp(int a, int b)
    {
        string c=to_string(a);
        string d=to_string(b);
        return c+d>d+c;
    }
};



190. Reverse Bits
method: bit manipulation
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
           n = (n >> 16) | (n << 16);
        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);
        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);
        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);
        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);
        return n;
    }
};



201. Bitwise AND of Numbers Range
method:bit
让我们从最低位开始。
如果这一组数字的最低位不相同的话，那这一位就肯定会被消掉，变成0.如果m!=n,那最低位肯定是要被消掉的，因为最低位肯定会是一个0，一个1(n,m不相同,说明至少m,m+1是包括在里面的).这时，我们可以将m和n都右移一位，将最后一位忽略。

此时，又有了新的一组m和n。如果此时m=n,那结果就是m了。如果不是的话，那可以继续上一段的过程，将m和n右移一位。
class Solution {
public:
    int rangeBitwiseAnd(int m, int n) {
        int count=0;
        while(m!=n)
        {
            m>>=1;
            n>>=1;
            count++;
        }
        return m<<count;
    }
};




202. Happy Number
method :the Floyd Cycle detection algorithm,like the two pointors 
class Solution {
public:
    int digitSquareSum(int n) {
    int sum = 0, tmp;
    while (n) {
        tmp = n % 10;
        sum += tmp * tmp;
        n /= 10;
    }
    return sum;
}

bool isHappy(int n) {
    int slow, fast;
    slow = fast = n;
    do {
        slow = digitSquareSum(slow);
        fast = digitSquareSum(fast);
        fast = digitSquareSum(fast);
    } while(slow != fast);
    if (slow == 1) return 1;
    else return 0;
}
};


203.  Remove Linked List Elements
method: linklist
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* res=head,* pre=head;
        
        while(head!=NULL)
        {
            if(head->val==val)
            {
                if(head==res)
                {
                    res=head->next;
                }
               pre->next=head->next;
               auto tmp=head;
               head=head->next;
               delete tmp;
            }
            else
            {
             pre=head;
             head=head->next;
            }
        }
        return res;
    }
};

method 2:recursive(java)
public ListNode removeElements(ListNode head, int val) {
        if (head == null) return null;
        head.next = removeElements(head.next, val);
        return head.val == val ? head.next : head;
}


206. Reverse Linked List
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
      ListNode* pre=NULL;
      while(head)
      {
          ListNode* post=head->next;
          head->next=pre;
          pre=head;
          head=post;
      }
      return pre;
    }
};



210. Course Schedule II
mymethod: bfs
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {
        vector<unordered_set<int>> graph=make_graph(numCourses,prerequisites);
        vector<int> indegree=compute_indegree(numCourses,graph);
        vector<int>  res;
        for(int i=0;i<numCourses;i++)
        {
            int j=0;
            for(j=0;j<numCourses;j++)
            {
                if(indegree[j]==0) break;
            }
            if(j==numCourses) return {};
            res.push_back(j);
            indegree[j]--;
            for(int k:graph[j])
            indegree[k]--;
        }
        return res;
    }
    vector<unordered_set<int>> make_graph(int numCourses, vector<pair<int, int>>& prerequisites)
    {
        vector<unordered_set<int>> graph(numCourses);
        for(pair<int, int> p:prerequisites)
        {
            graph[p.second].insert(p.first);
        }
        return graph;
    }
    vector<int> compute_indegree(int numCourses,vector<unordered_set<int>> graph)
    {
        vector<int> indegree(numCourses,0);
        for(auto s:graph)
        {
            for(int i:s)
            {
                indegree[i]++;
            }
        }
        return indegree;
    }
};




216.
class Solution {
public:
    void backtrack(vector<vector<int>> &res,vector<int> candidates,vector<int> combination,int target,int begin,int k)
    {
        if(!target&&combination.size()==k)
        {
            //if(combination.size()==k)
            res.push_back(combination);
            return;//return 
        }
       
     for(int i=begin;i<9&&target>=candidates[i];i++)//һ\B6\A8Ҫ\BC\D3&&\A3\A1
        {
            if(combination.size()<=k)
            {
            combination.push_back(candidates[i]);
            backtrack(res,candidates,combination,target-candidates[i],i+1,k);
            combination.pop_back();
            }
            
        }
       }
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> res;
        vector<int> candidates={1,2,3,4,5,6,7,8,9};
         if(n>45)
        return {};
        else
        {
        backtrack(res,candidates,{},n,0,k);
        return res;
        }
        
    }
};

217. Contains Duplicate
method:hash table
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        map<int,int> hs;
        for(int i=0;i<nums.size();i++)
        {
            hs[nums[i]]++;
            if(hs[nums[i]]>1)
            {
                return true;
                break;
            }
        }
        return false;
    }
};

219.
hash table
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        map<int,int> hs;
        for(int i=0;i<nums.size();i++)
        {
            
            if(hs.find(nums[i])==hs.end())
            {
                hs[nums[i]]=i;
            }
            else
            {
                if(i-hs[nums[i]]<=k)
                {
                return true;
                break;
                }
                else
                {
                    hs[nums[i]]=i;
                }
                
            }
        }
        return false;
    }
};

220. Contains Duplicate III
method:set ,lower_bound,binary search
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
        set<int> window; // set is ordered automatically 
    for (int i = 0; i < nums.size(); i++) {
        if (i > k) window.erase(nums[i-k-1]); // keep the set contains nums i j at most k
        
        // |x - nums[i]| <= t  ==> -t <= x - nums[i] <= t;
        // lower_bound(val):return the first iterator which >= val using binary search method
        auto pos = window.lower_bound(nums[i] - t); // x-nums[i] >= -t ==> x >= nums[i]-t  
        // x - nums[i] <= t ==> |x - nums[i]| <= t    
        if (pos != window.end() && *pos - nums[i] <= t) return true;
        window.insert(nums[i]);
    }
    return false;
    }
};

226.
my method 1: Recursive
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        TreeNode* tree=root,*tmp;
        if(tree==NULL)
        return root;
        tmp=invertTree(tree->right);
        tree->right=invertTree(tree->left);
        tree->left=tmp;
        return root;
        
    }
};

method 2: Non-Recursive
TreeNode* invertTree(TreeNode* root) {
    std::stack<TreeNode*> stk;
    stk.push(root);
    
    while (!stk.empty()) {
        TreeNode* p = stk.top();
        stk.pop();
        if (p) {
            stk.push(p->left);
            stk.push(p->right);
            std::swap(p->left, p->right);
        }
    }
    return root;
}



227. Basic Calculator II
method:
class Solution {
public:
    int calculate(string s) {
       istringstream in("+"+s+"+");
       int res=0,temp=0,n;
       char op;
       while(in>>op)
       {
           if(op=='+'||op=='-')
           {
               res+=temp;
               in>>temp;
               temp=op=='+'?temp:-temp;
           }
           else
           {
               in>>n;
               temp=op=='*'?temp*n:temp/n;
           }
       }
        return res;
        
    }
};



228. Summary Ranges
my method:
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        int i=0;
        vector<string> res;
        while(i<nums.size())
        {
            string s=to_string(nums[i]);
            int start=i;
            i++;
            while(i<nums.size()&&nums[i]==nums[i-1]+1)
            {
                i++;
            }
            if(i-1!=start)
            s+="->"+to_string(nums[i-1]);
            res.push_back(s);
        }
        return res;
    
    }
};




230. Kth Smallest Element in a BST
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
int value=0;
int count=0;
void inorder(TreeNode* root)
{
    if(root==NULL) return;
   inorder(root->left);
   count--;
    if(count==0) 
    {
        value=root->val;
        return;
    
    }
   inorder(root->right);
}
    int kthSmallest(TreeNode* root, int k) {
        count=k;
        inorder(root);
        
        return value;
    }
};



234.
method 1:use stack
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        stack<int> st;
        ListNode* post=head;
        while(post)
        {
            st.push(post->val);
            post=post->next;
        }
        while(head)
        {
            if(st.top()==head->val)
            {
                st.pop();
            }
            else
            break;
            head=head->next;
        }
        if(st.empty())
        return true;
        else
        return false;
        
    }
};

method 2: reverse use linked list
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* pre=NULL;
        ListNode* post=head;
       /** while(post)//reverse as below: position is unchanged!!
        {
            ListNode* tmp=post->next;
            post->next=pre;
            pre=post;
            post=tmp;
        }*/
        while(post)//reverse as below: position is changed!!
        {
            ListNode* tmp=new ListNode(post->val);
            tmp->next=pre;
            pre=tmp;
            post=post->next;
        }
        while(head)
        {
            if(pre->val!=head->val)
            {
            return false;
            break;
            }
            head=head->next;
            pre=pre->next;
        }
        
        return true;
    }
};


237. Delete Node in a Linked List
method 1:Since we do not have access to the node before the one we want to delete, we cannot modify the next pointer of that node in any way. Instead, we have to replace the value of the node we want to delete with the value in the node after it, and then delete the node after it.
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        *(node)=*(node->next);
      
    }
};

method 2 :delete the next node
class Solution {
public:
    void deleteNode(ListNode* node) {
        auto next=node->next;
        *node=*next;
        delete next;
    }
};

258.
method 1:
class Solution {
public:
    int addDigits(int num) {
        int res=num,x=num;
        while(res>=10)
        {
            res=0;
        while(num>0)
        {
            res+=num%10;
            num=num/10;
        }
        num=res;
        }
        return res;
    }
};

method:find the regular;9 kinds of results;
class Solution {
public:
    int addDigits(int num) {       
        return (num-1)%9+1;//num==0,res=0;num%9==0,res=9.
    }
};



278. First Bad Version
my method :binary search
// Forward declaration of isBadVersion API.
bool isBadVersion(int version);

class Solution {
public:
    int firstBadVersion(int n) {
        int low=1,high=n;
        while(low<high)
        {
            int mid=low+(high-low)/2;
            if(isBadVersion(mid)) high=mid;
            else low=mid+1;
        }
        return low;
    }
};



283. Move Zeroes
my method 1:
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int size=nums.size();
        int i=0;
        while(i<size)
        {
            if(nums[i]==0)
            {
                nums.erase(nums.begin()+i);//delete 0
                nums.push_back(0);
                size=size-1;//or it will loop endless
            }
            else
            i++;
        }
    }
};
method 2:All elements before the slow pointer (lastNonZeroFoundAt) are non-zeroes.
         All elements between the current and slow pointer are zeroes.
void moveZeroes(vector<int>& nums) {
    for (int lastNonZeroFoundAt = 0, cur = 0; cur < nums.size(); cur++) {
        if (nums[cur] != 0) {
            swap(nums[lastNonZeroFoundAt++], nums[cur]);
        }
    }
}


292.Nim Game 
method: find the regular
class Solution {
public:
    bool canWinNim(int n) {
        if(n%4==0)
        return false;
        else
        return true;
    }
};



289. Game of Life
method:
To solve it in place, we use 2 bits to store 2 states:

[2nd bit, 1st bit] = [next state, current state]

- 00  dead (next) <- dead (current)
- 01  dead (next) <- live (current)  
- 10  live (next) <- dead (current)  
- 11  live (next) <- live (current) 
In the beginning, every cell is either 00 or 01.
Notice that 1st state is independent of 2nd state.
Imagine all cells are instantly changing from the 1st to the 2nd state, at the same time.
Let's count # of neighbors from 1st state and set 2nd state bit.
Since every 2nd state is by default dead, no need to consider transition 01 -> 00.
In the end, delete every cell's 1st state by doing >> 1.
For each cell's 1st bit, check the 8 pixels around itself, and set the cell's 2nd bit.

Transition 01 -> 11: when board == 1 and lives >= 2 && lives <= 3.
Transition 00 -> 10: when board == 0 and lives == 3.
To get the current state, simply do

board[i][j] & 1
To get the next state, simply do

board[i][j] >> 1


class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {
        int m=board.size(),n=board[0].size();
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                int lives=liveNeighbor(i,j,m,n,board);
                //cout<<lives;
                if(board[i][j]==1&&(lives==2||lives==3))
                  board[i][j]=3;
                if(board[i][j]==0&&lives==3)
                  board[i][j]=2;
            }
        }
        
        for(int i=0;i<m;i++)
        for(int j=0;j<n;j++)
        board[i][j]>>=1;
    }
    
    int liveNeighbor(int i,int j,int m,int n,vector<vector<int>> board)
    {
        int lives=0;
        for(int x=max(i-1,0);x<=min(i+1,m-1);x++)
        for(int y=max(j-1,0);y<=min(j+1,n-1);y++)
        lives+=board[x][y]&1;
        
        lives-=board[i][j]&1;
        return lives;
    }
};




295. Find Median from Data Stream
method:
class MedianFinder {
public:
priority_queue<int> small,large;//large 存负的较大数
    // Adds a number into the data structure.
    void addNum(int num) {
        small.push(num);
        large.push(-small.top());
        small.pop();
        if(small.size()<large.size())
        {
            small.push(-large.top());
            large.pop();
        }
    }

    // Returns the median of current data stream
    double findMedian() {
        return small.size()==large.size()?(double)(small.top()-large.top())/2:small.top();
        
    }
};

// Your MedianFinder object will be instantiated and called as such:
// MedianFinder mf;
// mf.addNum(1);
// mf.findMedian();





301. Remove Invalid Parentheses
method:DFS
To make the prefix valid, we need to remove a ‘)’. The problem is: which one? The answer is any one in the prefix. However, if we remove any one, we will generate duplicate results, for example: s = ()), we can remove s[1] or s[2] but the result is the same (). Thus, we restrict ourself to remove the first ) in a series of concecutive )s.

After the removal, the prefix is then valid. We then call the function recursively to solve the rest of the string. However, we need to keep another information: the last removal position. If we do not have this position, we will generate duplicate by removing two ‘)’ in two steps only with a different order.
For this, we keep tracking the last removal position and only remove ‘)’ after that.

Now one may ask. What about ‘(‘? What if s = ‘(()(()’ in which we need remove ‘(‘?
The answer is: do the same from right to left.
However a cleverer idea is: reverse the string and reuse the code!

class Solution {
public:
    vector<string> removeInvalidParentheses(string s) {
        vector<string> res;
        remove(s, res, 0, 0, "()");
        return res;
    }
    void remove(string s, vector<string> &res, int last_i, int last_j,  string par) {
    for (int count = 0, i = last_i; i < s.size(); ++i) {
        if (s[i] == par[0]) count++;
        if (s[i] == par[1]) count--;
        if (count >= 0) continue;
        for (int j = last_j; j <= i; ++j)//last_j?
            if (s[j] == par[1] && (j == last_j || s[j - 1] != par[1]))
                remove(s.substr(0, j) + s.substr(j + 1), res, i, j, par);
        return;
    }
    string reversed = s;
    reverse(reversed.begin(),reversed.end());
    if (par[0] == '(') // finished left to right
        remove(reversed, res, 0, 0, ")(");
    else // finished right to left
        res.push_back(reversed);
}
};



310. Minimum Height Trees
method: bfs
It is easy to see that the last two pointers are from the two ends of the longest path in the graph.

The actual implementation is similar to the BFS topological sort. Remove the leaves, update the degrees of inner vertexes. Then remove the new leaves. Doing so level by level until there are 2 or 1 nodes left. What's left is our answer!

The time complexity and space complexity are both O(n).

class Solution {
public:
    vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {
        if (n == 1) return {0};
        vector<set<int>> graph(n,set<int>());
        for(pair<int,int> e:edges)
        {
            graph[e.first].insert(e.second);
            graph[e.second].insert(e.first);
        }
        vector<int> leaves;
        for(int i=0;i<n;i++)
        {
            if(graph[i].size()==1)
            leaves.push_back(i);
        }
        
        
        while(n>2)
        {
            n-=leaves.size();
            vector<int> newleaves;
            for(int i:leaves)
            {
                int nextleave=*graph[i].begin();
                graph[nextleave].erase(i);
                if(graph[nextleave].size()==1) newleaves.push_back(nextleave);
            }
            leaves=newleaves;
        }
        return leaves;
    }
};




328. Odd Even Linked List
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        ListNode* even=NULL,*evenhead=NULL,* odd=head;
        if(!head||head->next==NULL) return head;
        evenhead=head->next;
        even=head->next;
        while(1)
        {
            if(even->next)
            {
            odd->next=even->next;
            odd=even->next;
            }
           else break;
           even->next=odd->next;
            even=odd->next;
            if(!even) break;
        }
        odd->next=evenhead;
        return head;
    }
};


329. Longest Increasing Path in a Matrix
method:dp,dfs
The key is to cache the distance because it's highly possible to revisit a cell

class Solution {
private:
    vector<vector<int>> cache;
    vector<pair<int, int>> direction;
    int m, n;
    int DFS(int i, int j, vector<vector<int>>& matrix) {
        if(cache[i][j] != 0) return cache[i][j];
        int longest = 1;
        for(auto dir : direction) {
            int x = i + dir.first, y = j + dir.second;
            if(x < 0 || x >= m || y < 0 || y >= n || matrix[x][y] <= matrix[i][j]) {
                continue;
            } else {
                longest = max(longest, DFS(x, y, matrix) + 1);
            }
        }
        cache[i][j] = longest;
        return longest;
    }
public:
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        if(matrix.empty()) return 0;
        m = matrix.size(), n = matrix[0].size();
        direction.push_back(pair<int, int>(0, 1));
        direction.push_back(pair<int, int>(0, -1));
        direction.push_back(pair<int, int>(1, 0));
        direction.push_back(pair<int, int>(-1, 0));
        cache = vector<vector<int>>(m, vector<int>(n, 0));
        int longest = 1;
        for (int i = 0; i < m; i++) {
           for(int j = 0; j < n; j++) {
               longest = max(longest, DFS(i, j, matrix));
           } 
        }
        return longest;
    }
};



331. Verify Preorder Serialization of a Binary Tree
method:
Some used stack. Some used the depth of a stack. Here I use a different perspective. In a binary tree, if we consider null as leaves, then

all non-null node provides 2 outdegree and 1 indegree (2 children and 1 parent), except root
all null node provides 0 outdegree and 1 indegree (0 child and 1 parent).
Suppose we try to build this tree. During building, we record the difference between out degree and in degree diff = outdegree - indegree. When the next node comes, we then decrease diff by 1, because the node provides an in degree. If the node is not null, we increase diff by 2, because it provides two out degrees. If a serialization is correct, diff should never be negative and diff will be zero when finished.


class Solution {
public:
    bool isValidSerialization(string preorder) {
        int diff=1;
        while(preorder.find_first_of(',')!=string::npos)
        {
            int pos=preorder.find_first_of(',');
            string str=preorder.substr(0,pos);
            //cout<<pos<<",";
            if(--diff<0) return false;
            if(str!="#") diff+=2;
            preorder=preorder.substr(pos+1);
        }
        //cout<<preorder<<endl;
        if(--diff<0) return false;
        if(preorder!="#") diff+=2;
        return diff==0;
    }
};



332. Reconstruct Itinerary
method:dfs;
我们在dfs的时候，如果卡住了，那么说明访问到了终点，就把这个点放进vector中。如果没卡住的话，就把点push进stack中（用于回溯），并且一直访问下去，并且经过的点都要记得及时删除，防止走重复的路径。
class Solution {
public:
    vector<string> findItinerary(vector<pair<string, string>> tickets) {
        map<string,multiset<string>> hs;//maybe the same ticket
        for(pair<string, string> p:tickets)
        {
            hs[p.first].insert(p.second);
        }
        vector<string> res;
        stack<string> s;
        s.push("JFK");
        while(!s.empty())
        {
            string top=s.top();
            if(hs[top].size()==0)
            {
                res.push_back(top);
                s.pop();
            }
            else
            {
                s.push(*hs[top].begin());
                hs[top].erase(hs[top].begin());
            }
        }
        reverse(res.begin(),res.end());
        return res;
        
    }
    
};



338. Counting Bits
method 1 :use computed results
class Solution {
public:
    vector<int> countBits(int num) {
        vector<int> res;
        res.push_back(0);
        res.push_back(1);
        res.push_back(1);
        res.push_back(2);
        int begin=2;
        for(int i=4;i<=num;i++)
        {
            if(i%begin==0)
            {
                begin=begin*2;
                res.push_back(1);//it's not true:res[i]=1  unless defined as "vector<int> res(num+1);"
            }
            else
            {
                res.push_back(res[i%begin]+1);
            }
            
        }
        if(num<3)
        res.erase(res.begin()+num+1,res.end());
        //cout<<res.size()<<endl;
        return res;
    }
};

method 2:use &,ret[0]=0
class Solution {
public:
    vector<int> countBits(int num) {
        vector<int> ret(num+1, 0);
        for (int i = 1; i <= num; ++i)
            ret[i] = ret[i&(i-1)] + 1;
        return ret;
    }
};


349.
method1:hashtable  method2:two pointors
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        map<int,int> hs;
        vector<int> res;
        for(int i=0;i<nums1.size();i++) hs[nums1[i]]++;
        for(int i=0;i<nums2.size();i++) 
        {
            if(hs.find(nums2[i]) != hs.end())
            {
                res.push_back(nums2[i]);
                hs.erase(nums2[i]);
            }
        }
        return res;
    }
};

350.
method1\A3\BAtwo pointors
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        sort(nums1.begin(),nums1.end());
        sort(nums2.begin(),nums2.end());
        vector<int> res;
        int begin=0;
        /**for(int i=0;i<nums1.size();i++)
        {
            for(int j=begin;j<nums2.size();j++)
            {
                if(nums1[i]>nums2[j])
                {
                    begin++;
                }
                else if(nums1[i]==nums2[j])
                {
                    res.push_back(nums1[i]);
                    begin++;
                    break;
                }
                else
                {
                    break;
                }
            }
        }*/
        //more easy write style
        while(i<num1.size()&&j<num2.size())
            {
                if(nums1[i]>nums2[j])
                {
                    j++;
                }
                else if(nums1[i]==nums2[j])
                {
                    res.push_back(nums1[i]);
                    i++;
                    j++;
                }
                else
                {
                    i++;
                }

            }


        return res;
        
        
    }
};

method2\A3\BA hash table
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> dict;
        vector<int> res;
        for(int i = 0; i < (int)nums1.size(); i++) dict[nums1[i]]++;
        for(int i = 0; i < (int)nums2.size(); i++)
            if(--dict[nums2[i]] >= 0) res.push_back(nums2[i]);
        return res;
    }
};




355. Design Twitter
my method:
class Twitter {
public:
map<int,unordered_set<int>> follows;
int timecount=0;
map<int,vector<pair<int,int>>> tweetlist;
    /** Initialize your data structure here. */
    Twitter() {
        
    }
    
    /** Compose a new tweet. */
    void postTweet(int userId, int tweetId) {
        tweetlist[userId].push_back(make_pair(timecount++,tweetId));
    }
    
    /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */
    vector<int> getNewsFeed(int userId) {
        vector<int> res;
        map<int,int> hs;
        follows[userId].insert(userId);
        for(int i:follows[userId])
        {
            for(pair<int,int> p:tweetlist[i])
            {
                hs[p.first]=p.second;
            }
        }
        map<int,int>::reverse_iterator it;
        for(it=hs.rbegin();it!=hs.rend();it++)
        {
            res.push_back((*it).second);
            if(res.size()==10) break;
        }
        return res;
    }
    
    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */
    void follow(int followerId, int followeeId) {
        follows[followerId].insert(followeeId);
    }
    
    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */
    void unfollow(int followerId, int followeeId) {
        follows[followerId].erase(followeeId);
    }
};

/**
 * Your Twitter object will be instantiated and called as such:
 * Twitter obj = new Twitter();
 * obj.postTweet(userId,tweetId);
 * vector<int> param_2 = obj.getNewsFeed(userId);
 * obj.follow(followerId,followeeId);
 * obj.unfollow(followerId,followeeId);
 */




371. Sum of Two Integers 
method: bit manipulation
class Solution {
public:
    int getSum(int a, int b) {
       while(b)  //& can make carry,^ can make +
        {  
            int carry = a & b;  
            a = a ^ b;  //sum without carry
            b = carry << 1;  //add the carry to previous bit
        }  
        return a;  
    }
};



394. Decode String
my method:dfs
class Solution {
public:
    string decodeString(string s) {
        int preindex=s.find('[');
        int postindex=s.find(']');
       
        if(preindex==-1)  return s;
        
        int precount=0;
        int i=0;
        for(i=preindex;i<s.size();i++)
        {
            if(s[i]==']') precount--;
            if(s[i]=='[') precount++;
            if(precount==0) break;
        }
        postindex=i;
        
        string res;
        int numstart=0;
        for(numstart=0;numstart<s.size();numstart++)//a2[c] first is not num
        {
            if(s[numstart]>='0'&&s[numstart]<='9') break;
        }
        int num=atoi(s.substr(numstart,preindex-numstart).c_str());
        if(numstart!=0) res+=s.substr(0,numstart);
       
        for(int j=0;j<num;j++)
        {
            res+=decodeString(s.substr(preindex+1,postindex-preindex-1));
        }
        if(postindex!=s.size()-1) res+=decodeString(s.substr(postindex+1));
        
        return res;
    }
};


373. Find K Pairs with Smallest Sums
my method:最大堆
class Solution {
public:
struct cmp{
    bool operator()(pair<int,int> &a,pair<int,int> &b)
    {
        return a.first+a.second<b.first+b.second;
    }
};

    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {
        if(nums1.size()==0||nums2.size()==0) return {};
        priority_queue<pair<int,int>,vector<pair<int,int>>,cmp> q; 
        for(int i=0;i<nums1.size();i++)
        for(int j=0;j<nums2.size();j++)
        {
            q.push(make_pair(nums1[i],nums2[j]));
            if(q.size()>k) q.pop();
        }
        int size=q.size();
        vector<pair<int, int>> res(size);
        for(int i=size-1;i>=0;i--)
        {
            res[i]=q.top();
            q.pop();
        }
        return res;
    }
    
};



378. Kth Smallest Element in a Sorted Matrix
method: 
我们使用一个最大堆，然后遍历数组每一个元素，将其加入堆，根据最大堆的性质，大的元素会排到最前面，然后我们看当前堆中的元素个数是否大于k，大于的话就将首元素去掉，循环结束后我们返回堆中的首元素即为所求:
class Solution {
public:
    int kthSmallest(vector<vector<int>>& matrix, int k) {
        priority_queue<int,vector<int>> q;
        for(int i=0;i<matrix.size();i++)
        for(int j=0;j<matrix[0].size();j++)
        {
            q.push(matrix[i][j]);
            if(q.size()>k) q.pop();
        }
        return q.top();
    }
    
};


3. Longest Substring Without Repeating Characters
method £ºhashtable and two pointers;use two pointers can solve time limit
the basic idea is, keep a hashmap which stores the characters in string as keys and their positions as values, and keep two pointers which define the max substring. move the right pointer to scan through the string , and meanwhile update the hashmap. If the character is already in the hashmap, then move the left pointer to the right of the same character last found. Note that the two pointers can only move forward.
i is the slow j is the fast
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int max=0;
        map<char,int> hs;
        for(int i=0,j=0;j<s.size();j++)
        {
            if(hs[s[j]]>i)
            {
                i=hs[s[j]];
            }
            hs[s[j]]=j+1;
            max=max>j-i+1?max:j-i+1;
        }
        return max;
    }
};



5. Longest Palindromic Substring
my method:Expand Around Center
class Solution {
public:
    string longestPalindrome(string s) {
        int maxlen=INT_MIN;
        string res;
        for(int i=0;i<s.size();i++)
        {
            int j;
            for(j=0;i-j>=0&&i+j<s.size()&&s[i-j]==s[i+j];j++){}//odd ÆæÊý
            if(j*2-1>maxlen) 
            {
                maxlen=j*2-1;
                res=s.substr(i-j+1,maxlen);
            }
            for(j=0;i-j>=0&&i+j+1<s.size()&&s[i-j]==s[i+j+1];j++){}//even
            if(j*2>maxlen)
            {
                maxlen=j*2;
                res=s.substr(i-j+1,maxlen);
            }
        }
        return res;
    }
};



10. Regular Expression Matching
method:DP
class Solution {
public:
    bool isMatch(string s, string p) {
        if (p.empty())    return s.empty();
        
        if ('*' == p[1])
            // x* matches empty string or at least one character: x* -> xx*
            // *s is to ensure s is non-empty
            return (Match(s, p.substr(2)) || !s.empty() && (s[0] == p[0] || '.' == p[0]) && Match(s.substr(1), p));
        else
            return !s.empty() && (s[0] == p[0] || '.' == p[0]) && Match(s.substr(1), p.substr(1));
    }
    
    bool Match(string s, string p) {
        /**
         * f[i][j]: if s[0..i-1] matches p[0..j-1]
         * if p[j - 1] != '*'
         *      f[i][j] = f[i - 1][j - 1] && s[i - 1] == p[j - 1]
         * if p[j - 1] == '*', denote p[j - 2] with x
         *      f[i][j] is true iff any of the following is true
         *      1) "x*" repeats 0 time and matches empty: f[i][j - 2]
         *      2) "x*" repeats >= 1 times and matches "x*x": s[i - 1] == x && f[i - 1][j]
         * '.' matches any single character
         */
        int m = s.size(), n = p.size();
        vector<vector<bool>> f(m + 1, vector<bool>(n + 1, false));
        
        f[0][0] = true;
        for (int i = 1; i <= m; i++)
            f[i][0] = false;
        // p[0.., j - 3, j - 2, j - 1] matches empty iff p[j - 1] is '*' and p[0..j - 3] matches empty
        for (int j = 1; j <= n; j++)
            f[0][j] = j > 1 && '*' == p[j - 1] && f[0][j - 2];
        
        for (int i = 1; i <= m; i++)
            for (int j = 1; j <= n; j++)
                if (p[j - 1] != '*')
                    f[i][j] = f[i - 1][j - 1] && (s[i - 1] == p[j - 1] || '.' == p[j - 1]);
                else
                    // p[0] cannot be '*' so no need to check "j > 1" here
                    f[i][j] = f[i][j - 2] || (s[i - 1] == p[j - 2] || '.' == p[j - 2]) && f[i - 1][j];
        
        return f[m][n];
    }
};



11. Container With Most Water
method: two pointers
class Solution {
public:
    int maxArea(vector<int>& height) {
    int water = 0;
    int i = 0, j = height.size() - 1;
    while (i < j) {
        int h = min(height[i], height[j]);
        water = max(water, (j - i) * h);
        while (height[i] <= h && i < j) i++;
        while (height[j] <= h && i < j) j--;
    }
    return water;
}


};



15. 3Sum
method :two pointers;o(n*n) time
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ress;
        sort(nums.begin(),nums.end());
        for(int i=0;i<nums.size();i++)
        {
            if(i==0||(i!=0&&nums[i]!=nums[i-1]))
            {
                int low=i+1,high=nums.size()-1,sum=-nums[i];
                while(low<high)
                {
                    if(nums[low]+nums[high]==sum)
                    {
                        ress.push_back({nums[i],nums[low],nums[high]});
                        while(low<high&&nums[low]==nums[low+1]) low++;
                        while(low<high&&nums[high]==nums[high-1]) high--;
                        low++,high--;
                    }
                    else if(nums[low]+nums[high]<sum) low++;
                    else high--;
                      
                }
            }
        }
        return ress;
    }
};



16. 3Sum Closest
my method :two pointers
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(),nums.end());
        int sum,minsum=INT_MAX,res;
        for(int i=0;i<nums.size();i++)
        {
            if(i==0||(i!=0&&nums[i]!=nums[i-1]))
            {
                int low=i+1,high=nums.size()-1,sum=target-nums[i];
                while(low<high)
                {
                    if(minsum>abs(sum-nums[low]-nums[high]))
                    {
                        res=sum-nums[low]-nums[high];
                        minsum=abs(sum-nums[low]-nums[high]);
                    }
                          
                    if(nums[low]+nums[high]==sum) return target;
                    else if(nums[low]+nums[high]<sum)  low++;
                    else high--;
                }
            }
        }
        return target-res;
        
    }
   
};




18. 4Sum
method 1:
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> total;
        int n = nums.size();
        if(n<4)  return total;
        sort(nums.begin(),nums.end());
        for(int i=0;i<n-3;i++)
        {
            if(i>0&&nums[i]==nums[i-1]) continue;
            if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target) break;
            if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]<target) continue;
            for(int j=i+1;j<n-2;j++)
            {
                if(j>i+1&&nums[j]==nums[j-1]) continue;
                if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target) break;
                if(nums[i]+nums[j]+nums[n-2]+nums[n-1]<target) continue;
                int left=j+1,right=n-1;
                while(left<right){
                    int sum=nums[left]+nums[right]+nums[i]+nums[j];
                    if(sum<target) left++;
                    else if(sum>target) right--;
                    else{
                        total.push_back(vector<int>{nums[i],nums[j],nums[left],nums[right]});
                        do{left++;}while(nums[left]==nums[left-1]&&left<right);
                        do{right--;}while(nums[right]==nums[right+1]&&left<right);
                    }
                }
            }
        }
        return total;
    }
};

method 2:The first time win over 100%. Basic idea is using subfunctions for 3sum and 2sum, and keeping throwing all impossible cases. O(n^3) time complexity, O(1) extra space complexity.
public List<List<Integer>> fourSum(int[] nums, int target) {
		ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();
		int len = nums.length;
		if (nums == null || len < 4)
			return res;

		Arrays.sort(nums);

		int max = nums[len - 1];
		if (4 * nums[0] > target || 4 * max < target)
			return res;

		int i, z;
		for (i = 0; i < len; i++) {
			z = nums[i];
			if (i > 0 && z == nums[i - 1])// avoid duplicate
				continue;
			if (z + 3 * max < target) // z is too small
				continue;
			if (4 * z > target) // z is too large
				break;
			if (4 * z == target) { // z is the boundary
				if (i + 3 < len && nums[i + 3] == z)
					res.add(Arrays.asList(z, z, z, z));
				break;
			}

			threeSumForFourSum(nums, target - z, i + 1, len - 1, res, z);
		}

		return res;
	}

	/*
	 * Find all possible distinguished three numbers adding up to the target
	 * in sorted array nums[] between indices low and high. If there are,
	 * add all of them into the ArrayList fourSumList, using
	 * fourSumList.add(Arrays.asList(z1, the three numbers))
	 */
	public void threeSumForFourSum(int[] nums, int target, int low, int high, ArrayList<List<Integer>> fourSumList,
			int z1) {
		if (low + 1 >= high)
			return;

		int max = nums[high];
		if (3 * nums[low] > target || 3 * max < target)
			return;

		int i, z;
		for (i = low; i < high - 1; i++) {
			z = nums[i];
			if (i > low && z == nums[i - 1]) // avoid duplicate
				continue;
			if (z + 2 * max < target) // z is too small
				continue;

			if (3 * z > target) // z is too large
				break;

			if (3 * z == target) { // z is the boundary
				if (i + 1 < high && nums[i + 2] == z)
					fourSumList.add(Arrays.asList(z1, z, z, z));
				break;
			}

			twoSumForFourSum(nums, target - z, i + 1, high, fourSumList, z1, z);
		}

	}

	/*
	 * Find all possible distinguished two numbers adding up to the target
	 * in sorted array nums[] between indices low and high. If there are,
	 * add all of them into the ArrayList fourSumList, using
	 * fourSumList.add(Arrays.asList(z1, z2, the two numbers))
	 */
	public void twoSumForFourSum(int[] nums, int target, int low, int high, ArrayList<List<Integer>> fourSumList,
			int z1, int z2) {

		if (low >= high)
			return;

		if (2 * nums[low] > target || 2 * nums[high] < target)
			return;

		int i = low, j = high, sum, x;
		while (i < j) {
			sum = nums[i] + nums[j];
			if (sum == target) {
				fourSumList.add(Arrays.asList(z1, z2, nums[i], nums[j]));

				x = nums[i];
				while (++i < j && x == nums[i]) // avoid duplicate
					;
				x = nums[j];
				while (i < --j && x == nums[j]) // avoid duplicate
					;
			}
			if (sum < target)
				i++;
			if (sum > target)
				j--;
		}
		return;
	}




23. Merge k Sorted Lists
method: use mergetwolists function;method 2:implement priority queue
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        int n=lists.size();
        if(n==0) return NULL;
        if(n==1) return lists[0];
        if(n==2) return mergeTwoLists(lists[0],lists[1]);
        vector<ListNode*> part1,part2;
        part1.assign(lists.begin(),lists.begin()+n/2);
        part2.assign(lists.begin()+n/2,lists.end());
        return mergeTwoLists(mergeKLists(part1),mergeKLists(part2));
    }
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(!l1) return l2;
        if(!l2) return l1;
        ListNode* res=new ListNode(INT_MIN);
        ListNode* pre=res,*post=l1;
        res->next=l1;
        while(l2)
        {
            if(l2->val>=pre->val&&l2->val<=post->val)
            {
                ListNode* tmp=l2->next;
                pre->next=l2;
                l2->next=post;
                l2=tmp;
                pre=pre->next;
            }
            else
            {
                pre=pre->next;
                post=post->next;
            }
            if(post==NULL)
            {
                pre->next=l2;
                break;
            }
        }
        return res->next;
    }
};





26. Remove Duplicates from Sorted Array
method :two ponters;do not use erase ;notice the requirement:Do not allocate extra space for another array, you must do this in place with constant memory.
this problem asks us to move all distinct elements (suppose n totally) to the first n entries of the original array and return the value n.
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.empty()) return 0;
        int j=0;
        for(int i=1;i<nums.size();i++)
        {
            if(nums[i]!=nums[j])
            {
                nums[++j]=nums[i];
            }
            
        }
        return j+1;
    }
};



27. Remove Element
my method:
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int j=0;
        
        for(int i=0;i<nums.size();i++)
        {
            if(nums[i]!=val)
            {
            nums[j++]=nums[i];
            }
        }
        return j;
    }
};



28. Implement strStr()
my method:
class Solution {
public:
    int strStr(string haystack, string needle) {
        int m=haystack.size(),n=needle.size();
        if(m=n==0) return 0;
        for(int i=0;i<haystack.size();i++)
        {
            if(haystack[i]==needle[0])
            {
                if(haystack.size()-i>=n&&haystack.substr(i,n)==needle)
                return i;
            }
        }
        return -1;
    }
};



31. Next Permutation
my method:
1.Start from its last element, traverse backward to find the first one with index i that satisfy num[i-1] < num[i]. So, elements from num[i] to num[n-1] is reversely sorted.
2.To find the next permutation, we have to swap some numbers at different positions, to minimize the increased amount, we have to make the highest changed position as high as possible. Notice that index larger than or equal to i is not possible as num[i,n-1] is reversely sorted. So, we want to increase the number at index i-1, clearly, swap it with the smallest number between num[i,n-1] that is larger than num[i-1]. For example, original number is 121543321, we want to swap the '1' at position 2 with '2' at position 7.
3.The last step is to make the remaining higher position part as small as possible, we just have to reversely sort the num[i,n-1]
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i;
        for(i=nums.size()-1;i>0;i--)
        {
            if(nums[i-1]<nums[i]) break;
        }
        int pos=i;
        if(pos==0)
        {
            sort(nums.begin(),nums.end());
            return;
        }
        if(pos==nums.size()-1)
        {
            swap(nums[i-1],nums[i]);
            return ;
        }
        for(i=nums.size()-1;i>=pos;i--)
        {
            if(nums[i]>nums[pos-1])
            break;
        }
        swap(nums[i],nums[pos-1]);
        sort(nums.begin()+pos,nums.end());
    }
};



32. Longest Valid Parentheses
method:stack
1.Scan the string from beginning to end.
If current character is '(',
push its index to the stack. If current character is ')' and the
character at the index of the top of stack is '(', we just find a
matching pair so pop from the stack. Otherwise, we push the index of
')' to the stack.
2.After the scan is done, the stack will only
contain the indices of characters which cannot be matched. Then
let's use the opposite side - substring between adjacent indices
should be valid parentheses.
3.If the stack is empty, the whole input
string is valid. Otherwise, we can scan the stack to get longest
valid substring as described in step 3.

class Solution {
public:
    int longestValidParentheses(string s) {
        int count=0,sum=0;
        stack<int> st;
        for(int i=0;i<s.size();i++)
        {
            if(s[i]=='(') st.push(i);
            if(s[i]==')') 
            {
                if(!st.empty()&&s[st.top()]=='(') st.pop();
                else st.push(i);
            }
        }
        if(st.empty()) sum=s.size();
        int last=1,pre=0;
        while(!st.empty())
        {
            if(last==1)
            {
                sum=s.size()-1-st.top();
                last=0;
            }
            else
            {
                sum=max(sum,pre-st.top()-1);
            }
            pre=st.top();
            st.pop();
        }
        sum=max(sum,pre);
        return sum;
    
    }
};


method 2:DP
 I construct a array longest[], for any longest[i], it stores the longest length of valid parentheses which is end at i.

And the DP idea is :

If s[i] is '(', set longest[i] to 0,because any string end with '(' cannot be a valid one.

Else if s[i] is ')'

     If s[i-1] is '(', longest[i] = longest[i-2] + 2

     Else if s[i-1] is ')' and s[i-longest[i-1]-1] == '(', longest[i] = longest[i-1] + 2 + longest[i-longest[i-1]-2]

For example, input "()(())", at i = 5, longest array is [0,2,0,0,2,0], longest[5] = longest[4] + 2 + longest[1] = 6.

 int longestValidParentheses(string s) {
            if(s.length() <= 1) return 0;
            int curMax = 0;
            vector<int> longest(s.size(),0);
            for(int i=1; i < s.length(); i++){
                if(s[i] == ')'){
                    if(s[i-1] == '('){
                        longest[i] = (i-2) >= 0 ? (longest[i-2] + 2) : 2;
                        curMax = max(longest[i],curMax);
                    }
                    else{ // if s[i-1] == ')', combine the previous length.
                        if(i-longest[i-1]-1 >= 0 && s[i-longest[i-1]-1] == '('){
                            longest[i] = longest[i-1] + 2 + ((i-longest[i-1]-2 >= 0)?longest[i-longest[i-1]-2]:0);
                            curMax = max(longest[i],curMax);
                        }
                    }
                }
                //else if s[i] == '(', skip it, because longest[i] must be 0
            }
            return curMax;
        }



33. Search in Rotated Sorted Array
my method: binary search
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.size()==0) return -1;
        int low=0,high=nums.size()-1,minindex=0;
        while(low<=high)
        {
            if(nums[low]<=nums[high]) 
            {
                minindex=low;
                break;
            }
            int mid=low+(high-low)/2;
            if(nums[mid]>=nums[low]) low=mid+1;
            else high=mid;
        }
        
        if(minindex==0)
        {
            if(target>nums[nums.size()-1]||target<nums[0]) return -1;
            low=0,high=nums.size()-1;
        }
        else if(target>=nums[0]) low=0,high=minindex-1;
        else low=minindex,high=nums.size()-1;
        cout<<low<<high;
        while(low<=high)
        {
            int mid=low+(high-low)/2;
            if(nums[mid]==target) return mid;
            else if(nums[mid]<target) low=mid+1;
            else high=mid-1;
        }
        return -1;
        
    }
};



34. Search for a Range
my method: one binary search
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int low=0,high=nums.size()-1,mid=0;
        while(low<high)
        {
            mid=(low+high)/2;
            if(nums[mid]>target) high=mid-1;
            else if(nums[mid]<target) low=mid+1;
            else break;
        }
        cout<<mid;
        if(low>=high&&nums[low]!=target) return {-1,-1};
        if(low<high) low=mid,high=mid;
        
        while(low>=0&&nums[low]==target) low--;
        while(high<nums.size()&&nums[high]==target) high++;
        return {low+1,high-1};
        
    }
};

method 2;two binary search
vector<int> searchRange(int A[], int n, int target) {
    int i = 0, j = n - 1;
    vector<int> ret(2, -1);
    // Search for the left one
    while (i < j)
    {
        int mid = (i + j) /2;
        if (A[mid] < target) i = mid + 1;
        else j = mid;
    }
    if (A[i]!=target) return ret;
    else ret[0] = i;
    
    // Search for the right one
    j = n-1;  // We don't have to set i to 0 the second time.
    while (i < j)
    {
        int mid = (i + j) /2 + 1;	// Make mid biased to the right
        if (A[mid] > target) j = mid - 1;  
        else i = mid;				// So that this won't make the search range stuck.
    }
    ret[1] = j;
    return ret; 
}




35. Search Insert Position
my method :
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        
        int i;
        for(i=0;i<nums.size();i++)
        {
            if(nums[i]==target)
            return i;
            if(nums[i]>target)
            break;
        }
        if(i==nums.size()-1&&nums[i]<target)
        return i+1;
        else
        return i;
    }
};

method 2:binary search
 public int searchInsert(int[] A, int target) {
        int low = 0, high = A.length-1;
        while(low<=high){
            int mid = (low+high)/2;
            if(A[mid] == target) return mid;
            else if(A[mid] > target) high = mid-1;
            else low = mid+1;
        }
        return low;
    }



36. Valid Sudoku
my method 1: more time
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        
        for(int i=0;i<9;i++)
        {
            map<char,int> hs1;
            map<char,int> hs2;
            for(int j=0;j<9;j++)
            {
                hs1[board[i][j]]++;
                if(hs1[board[i][j]]==2&&board[i][j]!='.')
                return false;
                hs2[board[j][i]]++;
                if(hs2[board[j][i]]==2&&board[j][i]!='.')
                return false;
            }
        }
        for(int i=0;i<9;i+=3)
        for(int j=0;j<9;j+=3)
        {
            map<char,int> hs;
            for(int k=i;k<i+3;k++)
            for(int x=j;x<j+3;x++)
            {
                hs[board[k][x]]++;
                if(hs[board[k][x]]==2&&board[k][x]!='.')
                return false;
            }
        }
        return true;
        
    }
};

method 2:more space
used1: check each row
used2: check each column
used3: check each sub-boxes

class Solution
{
public:
    bool isValidSudoku(vector<vector<char> > &board)
    {
        int used1[9][9] = {0}, used2[9][9] = {0}, used3[9][9] = {0};
        
        for(int i = 0; i < board.size(); ++ i)
            for(int j = 0; j < board[i].size(); ++ j)
                if(board[i][j] != '.')
                {
                    int num = board[i][j] - '0' - 1, k = i / 3 * 3 + j / 3;
                    if(used1[i][num] || used2[j][num] || used3[k][num])
                        return false;
                    used1[i][num] = used2[j][num] = used3[k][num] = 1;
                }
        
        return true;
    }
};



38. Count and Say
my method:
class Solution {
public:
    string countAndSay(int n) {
        if(n==1) return "1";
        string res,s="1";
        for(int i=2;i<=n;i++)
        {
        res.clear();
        int count=1;
        if(s.size()==1)
        res+="1"+s;
        else
        {
        for(int i=1;i<s.size();i++)
        {
            if(s[i]==s[i-1])
            count++;
            else
            {
                res.push_back((count+'0'));
                res.push_back(s[i-1]);
                count=1;
            }
        }
        res.push_back((count+'0'));
        res.push_back(s.back());
        }
        s=res;
        }
        return res;
    }
};


42. Trapping Rain Water
method 1:
class Solution {
public:
    int trap(vector<int>& height) {
        //¹Û²ìÏÂŸÍ¿ÉÒÔ·¢ÏÖ±»Ë®ÌîÂúºóµÄÐÎ×ŽÊÇÏÈÉýºóœµµÄËþÐÎ£¬ÒòŽË£¬ÏÈ±éÀúÒ»±éÕÒµœËþ¶¥£¬È»ºó·Ö±ðŽÓÁœ±ß¿ªÊŒ£¬ÍùËþ¶¥ËùÔÚÎ»ÖÃ±éÀú£¬Ë®Î»Ö»»áÔöžß²»»áŒõÐ¡£¬ÇÒÒ»Ö±ºÍ×îœüÓöµœµÄ×îŽóžß¶È³ÖÆœ£¬ÕâÑùÖªµÀÁËÊµÊ±Ë®Î»£¬ŸÍ¿ÉÒÔ±ß±éÀú±ßŒÆËãÃæ»ý¡£
        int maxh=INT_MIN,maxindex=0;
        for(int i=0;i<height.size();i++)
        {
            if(maxh<height[i])
            {
                maxh=height[i];
                maxindex=i;
            }
        }
        int localmax=0,res=0;
        for(int i=0;i<maxindex;i++)
        {
            localmax=max(localmax,height[i]);
            res+=localmax-height[i];
        }
        localmax=0;
        for(int i=height.size()-1;i>maxindex;i--)
        {
            localmax=max(localmax,height[i]);
            res+=localmax-height[i];
        }
        return res;
        
    }
};

method 2:(ËŒÏëºÍ1ÀàËÆ£¬±ÈœÏÐ¡µÄÒ»±ßÍùÖÐŒä×îŽóµÄ¿¿Áú)
ÕâÀïŒÆËãÃæ»ý²»ÓÃÒ»°ãŒžºÎÊéµÄ·œ·š£¬ÕâÀïÊÇÁœ±ßÍùÖÐŒä±éÀú£¬ŒÇÂŒµ±Ç°µÚ¶þžßµãsecHight£¬È»ºóÀûÓÃÕâžöµÚ¶þžßµãŒõÈ¥µ±Ç°ÀúŸ­µÄÖù×Ó£¬Ê£ÏÂŸÍ×°Ë®ÈÝÁ¿ÁË¡£

ÎªÊ²ÃŽÊÇµÚ¶þžßµã£¿ÒòÎªÁœ±ß±ÈœÏ£¬×îžßµÄµã²»ÓÃ¶¯£¬Ö»ÒÆ¶¯µÚ¶þžßµã¡£

int trap(int A[], int n) {
		int secHight = 0;
		int left = 0;
		int right = n-1;
		int area = 0;
		while (left < right){
			if (A[left] < A[right]){
				secHight = max(A[left], secHight);
				area += secHight-A[left];//ŒÆËãµ±Ç°žñµÄÄÜ×°ÓêË®µÄÈÝÁ¿
				left++;
			} else {
				secHight = max(A[right], secHight);
				area += secHight-A[right];
				right--;
			}
		}
		return area;
	}




44. Wildcard Matching
method:
class Solution {
public:
    bool isMatch(string s, string p) {
        int i=0,j=0,star=-1,match=0;
        while(i<s.size())
        {
            if(p[j]=='?'||p[j]==s[i])
            {
                i++;
                j++;
            }
            else if(p[j]=='*')
            {
                star=j;
                match=i;
                j++;
            }
            else if(star!=-1)// last pattern pointer was *, advancing string pointer
            {
                j=star+1;
                match++;
                i=match;
            }
            //current pattern pointer is not star, last patter pointer was not *
          //characters do not match
            else return false;
        }
        while(j<p.size()&&p[j]=='*') j++;
        return j==p.size();
    }
};



46. Permutations
my method: backtrack
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> ress;
        vector<int> res;
        backtrack(ress,nums,res,nums,0);
        return ress;
    }
    void backtrack(vector<vector<int>> &ress,vector<int> nums,vector<int> res,vector<int> tmp,int i)
    {
        if(i==nums.size())
        {
            ress.push_back(res);
            return;
        }
        
        for(int j=0;j<tmp.size();j++)
        {
            int t=tmp[j];
            res.push_back(tmp[j]);
            tmp.erase(tmp.begin()+j);
            backtrack(ress,nums,res,tmp,i+1);
            res.erase(res.end()-1);//²»ÍùÏÂ×ßŸÍÒª»ØžŽÔ­Ñù
            tmp.insert(tmp.begin()+j,t);
        }
    }
};

method 2:
class Solution {
public:
    vector<vector<int> > permute(vector<int> &num) {
	    vector<vector<int> > result;
	    
	    permuteRecursive(num, 0, result);
	    return result;
    }
    
    // permute num[begin..end]
    // invariant: num[0..begin-1] have been fixed/permuted
	void permuteRecursive(vector<int> &num, int begin, vector<vector<int> > &result)	{
		if (begin >= num.size()) {
		    // one permutation instance
		    result.push_back(num);
		    return;
		}
		
		for (int i = begin; i < num.size(); i++) {
		    swap(num[begin], num[i]);
		    permuteRecursive(num, begin + 1, result);
		    // reset
		    swap(num[begin], num[i]);
		}
    }
};



47. Permutations II
method:
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        vector<vector<int>> ress;
        sort(nums.begin(),nums.end());
        backtrack(ress,nums,0);
        return ress;
    }
    void backtrack(vector<vector<int>> &ress,vector<int> nums,int begin)
    {
        if(begin==nums.size()-1)
        {
            ress.push_back(nums);
        }
        for(int i=begin;i<nums.size();i++)
        {
            if(nums[begin]==nums[i]&&begin!=i) continue;
            swap(nums[begin],nums[i]);
            backtrack(ress,nums,begin+1);
        }
    }
};



48. Rotate Image
method:
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        /*
 * clockwise rotate
 * first reverse up to down, then swap the symmetry 
 * 1 2 3     7 8 9     7 4 1
 * 4 5 6  => 4 5 6  => 8 5 2
 * 7 8 9     1 2 3     9 6 3
*/
        reverse(matrix.begin(),matrix.end());
        for(int i=0;i<matrix.size();i++)
        for(int j=i+1;j<matrix[0].size();j++)//j=i+1.²»È»ÖØžŽ
        {
            swap(matrix[i][j],matrix[j][i]);
        }
    }
};



49. Group Anagrams
my method 1: hashtable
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> res(strs.size(),vector<string>());
        int count=0;
        map<map<char,int>,int> hs1;
        for(int i=0;i<strs.size();i++)
        {
            map<char,int> hs;
            for(int j=0;j<strs[i].size();j++)
            {
                hs[strs[i][j]]++;
            }
            int index;
            if(hs1.find(hs)!=hs1.end())
            index=hs1[hs];
            else
            {
                index=count;
                hs1[hs]=count++;
            }
            res[index].push_back(strs[i]);
        }
        res.resize(count);//delete the empyty one
        return res;
    }
};

method 2:sort and hashtable
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, multiset<string>> mp;
        for (string s : strs) {
            string t = s; 
            sort(t.begin(), t.end());
            mp[t].insert(s);
        }
        vector<vector<string>> anagrams;
        for (auto m : mp) { 
            vector<string> anagram(m.second.begin(), m.second.end());
            anagrams.push_back(anagram);
        }
        return anagrams;
    }
};



50. Pow(x, n)
method:binary search;math
class Solution {
public:
    double myPow(double x, int n) {
        if(n==0) return 1;
        if(n<0)
        {
            x=1/x;
            if(n==INT_MIN)
            return x*myPow(x,INT_MAX);
            else
            n=-n;
        }
        return (n%2==0)?myPow(x*x,n/2):x*myPow(x*x,n/2);
    }
};



51. N-Queens
my method: backtrack;Í¬Ò»ÐÐÍ¬Ò»ÁÐÍ¬Ò»Ð±ÏßÉÏ¶Œ²»ÄÜÓÐÁœžöq
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> ress;
        string st;
        for(int i=0;i<n;i++)
        st.push_back('0');
        vector<string> res(n,st);//ÐèÒª³õÊŒ»¯
        backtrack(ress,res,0,n);
        return ress;
    }
    void backtrack(vector<vector<string>> &ress,vector<string> res,int k,int n)
    {
        if(k==n)
        {
            ress.push_back(res);
            return;
        }
        for(int i=0;i<n;i++)
        {
            if(res[k][i]=='.') continue;
            vector<string> tmp=res;
            int j=0;
            while(j<n)
            {
              res[k][j]='.';
              res[j++][i]='.';
            }
            int x=k,y=i;//right-bottom
            while(x<n&&y<n)
            res[x++][y++]='.';
            x=k,y=i; //left-bottom
            while(x<n&&y>=0)
            res[x++][y--]='.';
            
            res[k][i]='Q';
            backtrack(ress,res,k+1,n);
            res=tmp;
        }
    }
};



52. N-Queens II
my method :backtrack
class Solution {
public:
    int totalNQueens(int n) {
        int ress=0;
        string st;
        for(int i=0;i<n;i++)
        st.push_back('0');
        vector<string> res(n,st);//ÐèÒª³õÊŒ»¯
        backtrack(ress,res,0,n);
        return ress;
    }
    void backtrack(int &ress,vector<string> res,int k,int n)
    {
        if(k==n)
        {
            ress++;
            return;
        }
        for(int i=0;i<n;i++)
        {
            if(res[k][i]=='.') continue;
            vector<string> tmp=res;
            int j=0;
            while(j<n)
            {
              res[k][j]='.';
              res[j++][i]='.';
            }
            int x=k,y=i;//right-bottom
            while(x<n&&y<n)
            res[x++][y++]='.';
            x=k,y=i; //left-bottom
            while(x<n&&y>=0)
            res[x++][y--]='.';
            
            res[k][i]='Q';
            backtrack(ress,res,k+1,n);
            res=tmp;
        }
    }
};



53. Maximum Subarray
method: DP
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int maxendinghere=nums[0],maxsofar=nums[0];
        for(int i=1;i<nums.size();i++)
        {
            maxendinghere=max(maxendinghere+nums[i],nums[i]);
            maxsofar=max(maxsofar,maxendinghere);
        }
        return maxsofar;
    }
};



54. Spiral Matrix
my method :
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;
        int row=matrix.size();
        if(row==0) return {};
        int column=matrix[0].size();
        int count=0;
        for(int i=row,k=column;i>=1&&k>=1;i-=2,k-=2)
        {
            for(int j=count;j<count+k;j++)//from left to right
                res.push_back(matrix[count][j]);
            for(int j=count+1;j<count+i;j++)//from top to down
                res.push_back(matrix[j][count+k-1]);
            for(int j=count+k-2;j>=count&&count+i-1!=count;j--)//&& is for not repeat
                res.push_back(matrix[count+i-1][j]);
            for(int j=count+i-2;j>count&&count!=count+k-1;j--)
                res.push_back(matrix[j][count]);
            count++;
        }
        return res;
    }
};



55. Jump Game
my method:
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int zero=-1,i=0;
        while(i<nums.size())
        {
            if(nums[i]==0) 
            {
                if(i!=nums.size()-1)
                {
                zero=i-1;
                while(zero>=0)
                {
                    if(nums[zero]>i-zero) 
                    {
                        i++;
                        break;
                    }
                    zero--;
                }
                if(zero==-1) return false;
                }
                else if(i==0&&nums.size()!=1) return false;
                else return true;
            }
            else i++;
        }
        
        return true;
    }
   
};

method 2:greedy;iterate and update the maximal index that I can reach
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int reach=0,i=0;
        for(i=0;i<nums.size()&&i<=reach;i++)//i>reach  ËµÃ÷µœ²»ÁËi
        reach=max(reach,i+nums[i]);
        return i==nums.size();
    }
   
};


56. Merge Intervals(ºÏ²¢ÖØžŽÇøŒä)
my method:
/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    vector<Interval> merge(vector<Interval>& intervals) {
        int i=0;
        if(intervals.size()==0) return {};
        sort(intervals.begin(),intervals.end(),cmp);
        while(i<intervals.size()-1)
        {
            if(intervals[i+1].start<=intervals[i].end)
            {
                intervals[i].end=max(intervals[i].end,intervals[i+1].end);
                intervals.erase(intervals.begin()+i+1);
            }
            else i++;
        }
        return intervals;
    }
    static bool cmp(Interval x,Interval y)
    {
        if(x.start==y.start) return x.end<y.end;
        return x.start<y.start;
    }
};



57. Insert Interval
my method:
/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {
        if(intervals.size()==0) intervals.push_back(newInterval);
        int i=-1;
        for(i=0;i<intervals.size();i++)
        {
            if(intervals[i].start>newInterval.start)
            {
                int flag=true;
                if(i!=0&&(intervals[i-1].end>=newInterval.start||intervals[i-1].start==newInterval.start))
                {
                    intervals[i-1].end=max(intervals[i-1].end,newInterval.end);
                    flag=false;
                }
                else
                intervals.insert(intervals.begin()+i,newInterval);
                int j=flag==true?i:i-1;
                while(j<intervals.size()-1)
                {
                    if(intervals[j].end>=intervals[j+1].start)
                    {
                        intervals[j].end=max(intervals[j].end,intervals[j+1].end);
                        intervals.erase(intervals.begin()+j+1);
                    }
                    else
                    break;
                }
                break;
            }
        }
        if(i==intervals.size())
        {
            if(newInterval.start<=intervals[i-1].end)
            {
                intervals[i-1].end=max(intervals[i-1].end,newInterval.end);
            }
            else
            intervals.push_back(newInterval);
        }
        return intervals;
    }
};




58. Length of Last Word
my method:
class Solution {
public:
    int lengthOfLastWord(string s) {
        int sum=0;
        int index=s.find_last_of(' ');
        if(index==-1)
        return s.size();
        else if(index==s.size()-1)
        {
            s.erase(s.end()-1);
            return lengthOfLastWord(s);
        }
        else
        return s.size()-1-index;
        
    }
};



59. Spiral Matrix II
my method :
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        if(n==0) return {};
        vector<vector<int>> res(n,vector<int>(n,0));//ÐèÒª³õÊŒ»¯
        int count=0,num=1;
        for(int i=n;i>=1;i-=2)
        {
            for(int j=count;j<count+i;j++)//from left to right
                res[count][j]=num++;
            for(int j=count+1;j<count+i;j++)//from top to down
                res[j][count+i-1]=num++;
            for(int j=count+i-2;j>=count;j--)
                res[count+i-1][j]=num++;
            for(int j=count+i-2;j>count;j--)
                res[j][count]=num++;
            count++;
        }
        return res;
    }
};



60. Permutation Sequence
method:DP is TLO
ÔÚn!žöÅÅÁÐÖÐ£¬µÚÒ»Î»µÄÔªËØ×ÜÊÇ(n-1)!Ò»×é³öÏÖµÄ£¬Ò²ŸÍËµÈç¹ûp = k / (n-1)!£¬ÄÇÃŽÅÅÁÐµÄ×î¿ªÊŒÒ»žöÔªËØÒ»¶šÊÇnums[p]¡£

ŒÙÉèÓÐnžöÔªËØ£¬µÚKžöpermutationÊÇ
a1, a2, a3, .....   ..., an
ÄÇÃŽa1ÊÇÄÄÒ»žöÊý×ÖÄØ£¿
ÄÇÃŽÕâÀï£¬ÎÒÃÇ°Ña1È¥µô£¬ÄÇÃŽÊ£ÏÂµÄpermutationÎª
a2, a3, .... .... an, ¹²ŒÆn-1žöÔªËØ¡£ n-1žöÔªËØ¹²ÓÐ(n-1)!×éÅÅÁÐ£¬ÄÇÃŽÕâÀïŸÍ¿ÉÒÔÖªµÀ
Éè±äÁ¿K1 = K
a1 = K1 / (n-1)!
Í¬Àí£¬a2µÄÖµ¿ÉÒÔÍÆµŒÎª
a2 = K2 / (n-2)!
K2 = K1 % (n-1)!

class Solution {
public:
   string getPermutation(int n, int k) {  
        vector<int> nums(n);  
        int pCount = 1;  
        for(int i = 0 ; i < n; ++i) {  
            nums[i] = i + 1;  
            pCount *= (i + 1);  
        }  
  
        k--;  
        string res = "";  
        for(int i = 0 ; i < n; i++) {  
            pCount = pCount/(n-i);  
            int selected = k / pCount;  
            res += ('0' + nums[selected]);  
              
            for(int j = selected; j < n-i-1; j++)  
                nums[j] = nums[j+1];  
            k = k % pCount;  
        }  
        return res;  
    }  
    
};




62. Unique Paths
method :DP
This is a fundamental DP problem. First of all, let's make some observations.

Since the robot can only move right and down, when it arrives at a point, there are only two possibilities:

It arrives at that point from above (moving down to that point);
It arrives at that point from left (moving right to that point).
Thus, we have the following state equations: suppose the number of paths to arrive at a point (i, j) is denoted as P[i][j], it is easily concluded that P[i][j] = P[i - 1][j] + P[i][j - 1].

The boundary conditions of the above equation occur at the leftmost column (P[i][j - 1] does not exist) and the uppermost row (P[i - 1][j] does not exist). These conditions can be handled by initialization (pre-processing) --- initialize P[0][j] = 1, P[i][0] = 1 for all valid i, j. Note the initial value is 1 instead of 0!

class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> res(m,vector<int>(n,1));
        for(int i=1;i<m;i++)
        for(int j=1;j<n;j++)
        res[i][j]=res[i-1][j]+res[i][j-1];
        return res[m-1][n-1];
    }
};



63. Unique Paths II
my method:DP;°ÑÎª1µÄdpÉèÎª0
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int n=obstacleGrid.size();
        if(n==0) return 0;
        int m=obstacleGrid[0].size();
        vector<vector<int>> res(n,vector<int>(m,1));
        if(obstacleGrid[0][0]==1) return 0;
        for(int i=1;i<n;i++)
        {
            if(obstacleGrid[i][0]==1) res[i][0]=0;
            else res[i][0]=res[i-1][0];
        }
        for(int j=1;j<m;j++)
        {
            if(obstacleGrid[0][j]==1) res[0][j]=0;
            else res[0][j]=res[0][j-1];
        }
        for(int i=1;i<n;i++)
        for(int j=1;j<m;j++)
        {
            if(obstacleGrid[i][j]==1) res[i][j]=0;
            else
            res[i][j]=res[i][j-1]+res[i-1][j];
            //cout<<res[0][0];
        }
        return res[n-1][m-1];
    }
};




64. Minimum Path Sum
my method: dp
class Solution {

public:
    
int minPathSum(vector<vector<int>>& grid) {
        
int min=grid[0][0];
        
int m=grid.size(),n=grid[0].size();
        
vector<vector<int>> sum(m,vector<int>(n,min));
        
for(int i=1;i<m;i++)
        
sum[i][0]=sum[i-1][0]+grid[i][0];
        
for(int i=1;i<n;i++)
        
sum[0][i]=sum[0][i-1]+grid[0][i];
        
for(int i=1;i<m;i++)
        
for(int j=1;j<n;j++)
        
sum[i][j]=(sum[i-1][j]<sum[i][j-1]?sum[i-1][j]:sum[i][j-1])+grid[i][j];
        
return sum[m-1][n-1];
    
}
};

method 2:optional o(n) space
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<int> cur(m, grid[0][0]);
        for (int i = 1; i < m; i++)
            cur[i] = cur[i - 1] + grid[i][0]; 
        for (int j = 1; j < n; j++) {
            cur[0] += grid[0][j]; 
            for (int i = 1; i < m; i++)
                cur[i] = min(cur[i - 1], cur[i]) + grid[i][j];
        }
        return cur[m - 1];
    }
};



65. Valid Number
method:
class Solution {
public:
    bool isNumber(string s) {
        int i = 0;
    
    // skip the whilespaces
    for(; s[i] == ' '; i++) {}
    
    // check the significand
    if(s[i] == '+' || s[i] == '-') i++; // skip the sign if exist
    
    int n_nm, n_pt;
    for(n_nm=0, n_pt=0; (s[i]<='9' && s[i]>='0') || s[i]=='.'; i++)
        s[i] == '.' ? n_pt++:n_nm++;       
    if(n_pt>1 || n_nm<1) // no more than one point, at least one digit
        return false;
    
    // check the exponent if exist
    if(s[i] == 'e') {
        i++;
        if(s[i] == '+' || s[i] == '-') i++; // skip the sign
        
        int n_nm = 0;
        for(; s[i]>='0' && s[i]<='9'; i++, n_nm++) {}
        if(n_nm<1)
            return false;
    }
    
    // skip the trailing whitespaces
    for(; s[i] == ' '; i++) {}
    
    return s[i]==0;  // must reach the ending 0 of the string
        
    }
};



66. Plus One
my method :
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        vector<int> res;
        int rem=0;
        for(int i=digits.size()-1;i>=0;i--)
        {
            int sum;
            if(i==digits.size()-1)
            sum=digits[i]+1;
            else
            sum=digits[i]+rem;
            if(sum>=10) rem=1;
            else rem=0;
            sum=sum%10;
            res.insert(res.begin(),sum);
        }
        if(rem==1)
        res.insert(res.begin(),1);
        return res;
    }
};


69. Sqrt(x) 
method:binary search;sqrt(2)=1 ŒŽÍùÐ¡ÁËÈ¡
class Solution {
public:
    int mySqrt(int x) {
        if(x==0) return 0;
        int low=1,high=x;
        while(low<=high)
        {
            int mid=low+(high-low)/2;
            if(mid>x/mid) high=mid-1;
            else 
            {
                if(mid+1>x/(mid+1)) return mid;
                low=mid+1;
            }
        }
        return 0;
        
    }
};



70. Climbing Stairs
my method:
class Solution {
public:
    int climbStairs(int n) {
        int ppre=1,pre=2,now;//last step can be one or two
        if(n==0) return 0;
        if(n==1) return ppre;
        if(n==2) return pre;
        for(int i=3;i<=n;i++)
        {
            now=ppre+pre;
            ppre=pre;
            pre=now;
        }
        
        return now;
    }
};



72. Edit Distance
method:dp
This is a classic problem of Dynamic Programming. We define the state dp[i][j] to be the minimum number of operations to convert word1[0..i - 1] to word2[0..j - 1]. The state equations have two cases: the boundary case and the general case. Note that in the above notations, both i and j take values starting from 1.

For the boundary case, that is, to convert a string to an empty string, it is easy to see that the mininum number of operations to convert word1[0..i - 1] to "" requires at least i operations (deletions). In fact, the boundary case is simply:

dp[i][0] = i;
dp[0][j] = j.
Now let's move on to the general case, that is, convert a non-empty word1[0..i - 1] to another non-empty word2[0..j - 1]. Well, let's try to break this problem down into smaller problems (sub-problems). Suppose we have already known how to convert word1[0..i - 2] to word2[0..j - 2], which is dp[i - 1][j - 1]. Now let's consider word[i - 1] and word2[j - 1]. If they are euqal, then no more operation is needed and dp[i][j] = dp[i - 1][j - 1]. Well, what if they are not equal?

If they are not equal, we need to consider three cases:

Replace word1[i - 1] by word2[j - 1] (dp[i][j] = dp[i - 1][j - 1] + 1 (for replacement));
Delete word1[i - 1] and word1[0..i - 2] = word2[0..j - 1] (dp[i][j] = dp[i - 1][j] + 1 (for deletion));
Insert word2[j - 1] to word1[0..i - 1] and word1[0..i - 1] + word2[j - 1] = word2[0..j - 1] (dp[i][j] = dp[i][j - 1] + 1 (for insertion)).
Make sure you understand the subtle differences between the equations for deletion and insertion. For deletion, we are actually converting word1[0..i - 2] to word2[0..j - 1], which costs dp[i - 1][j], and then deleting the word1[i - 1], which costs 1. The case is similar for insertion.

Putting these together, we now have:

dp[i][0] = i;
dp[0][j] = j;
dp[i][j] = dp[i - 1][j - 1], if word1[i - 1] = word2[j - 1];
dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1), otherwise.
The above state equations can be turned into the following code directly.

class Solution { 
public:
    int minDistance(string word1, string word2) { 
        int m = word1.length(), n = word2.length();
        vector<vector<int> > dp(m + 1, vector<int> (n + 1, 0));
        for (int i = 1; i <= m; i++)
            dp[i][0] = i;
        for (int j = 1; j <= n; j++)
            dp[0][j] = j;  
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1[i - 1] == word2[j - 1]) 
                    dp[i][j] = dp[i - 1][j - 1];
                else dp[i][j] = min(dp[i - 1][j - 1] + 1, min(dp[i][j - 1] + 1, dp[i - 1][j] + 1));
            }
        }
        return dp[m][n];
    }
};



73. Set Matrix Zeroes
method:O(1) SPACE
store states of each row in the first of that row, and store states of each column in the first of that column. Because the state of row0 and the state of column0 would occupy the same cell, I let it be the state of row0, and use another variable "col0" for column0. In the first phase, use matrix elements to set states in a top-down way. In the second phase, use states to set matrix elements in a bottom-up way.
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m=matrix.size();
        if(m==0) return;
        int n=matrix[0].size(),col0=1;
        for(int i=0;i<m;i++)
        {
            if(matrix[i][0]==0) col0=0;//°Ñmatrix[0][0]ÉèÎª0»á°ÑµÚÒ»ÐÐÒ²È«ÉèÎª0
        for(int j=1;j<n;j++)
        {
            if(matrix[i][j]==0)
            {
                matrix[i][0]=0;
                matrix[0][j]=0;
            }
        }
        }
        for(int i=m-1;i>=0;i--)
        {
        for(int j=n-1;j>0;j--)
        {
            if(matrix[i][0]==0||matrix[0][j]==0)
            matrix[i][j]=0;
            
        }
        if(col0==0) matrix[i][0]=0;//ÉèµÚÒ»ÐÐ
        }
        return;
    }
};



74. Search a 2D Matrix
my method:
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if(matrix.size()==0) return false;
        int i=0;
        for(i=0;i<matrix.size();i++)
        {
            if(matrix[i][0]>target)
            break;
        }
        if(i==0) return false;
        for(int j=0;j<matrix[i-1].size();j++)
        {
            if(matrix[i-1][j]==target) return true;
        }
        return false;
    }
};
method 2:binary search
n * m matrix convert to an array => matrix[x][y] => a[x * m + y]

an array convert to n * m matrix => a[x] =>matrix[x / m][x % m];

class Solution {
public:
    bool searchMatrix(vector<vector<int> > &matrix, int target) {
        int n = matrix.size();
        int m = matrix[0].size();
        int l = 0, r = m * n - 1;
        while (l != r){
            int mid = (l + r - 1) >> 1;
            if (matrix[mid / m][mid % m] < target)
                l = mid + 1;
            else 
                r = mid;
        }
        return matrix[r / m][r % m] == target;
    }
};



76. Minimum Window Substring
method: hashtable;twopointers
class Solution {
public:
    string minWindow(string s, string t) {
        map<char,int> hs;
        for(int i=0;i<t.size();i++)
        {
            hs[t[i]]++;
        }
        int slow=0,head=0,counter=t.size(),mincount=INT_MAX;
        for(int i=0;i<s.size();i++)
        {
            if(hs[s[i]]-->0) counter--;
            while(counter==0)//°üº¬ÁËt,È¥³ýÇ°ÃæµÄ
            {
                if(mincount>i-slow+1) mincount=i-slow+1,head=slow;
                if(hs[s[slow++]]++==0) counter++;
            }
        }
        return mincount==INT_MAX?"":s.substr(head,mincount);
    }
};



77. Combinations
method :backtrack
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ress;
        backtrack(ress,{},1,k,n);
        return ress;
    }
    void backtrack(vector<vector<int>> &ress,vector<int> res,int begin,int k,int n)
    {
        if(k==0)
        {
            ress.push_back(res);
            return;
        }
        for(int i=begin;i<=n;i++)
        {
            res.push_back(i);
            backtrack(ress,res,i+1,k-1,n);//²»ÊÇbegin+1
            res.erase(res.end()-1);
        }
    }
};


78. Subsets
my method 1:backtrack
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> ress;
        for(int k=0;k<=nums.size();k++)
        {
        backtrack(ress,k,{},nums,0);
        }
        return ress;
    }
    void backtrack(vector<vector<int>> &ress,int k,vector<int> res,vector<int> nums,int begin)
    {
        if(k==0)
        {
            ress.push_back(res);
            return;
        }
        for(int j=begin;j<nums.size();j++)
        {
            res.push_back(nums[j]);
            backtrack(ress,k-1,res,nums,j+1);
            res.pop_back();
        }
    }
};

žüºÃµÄ°æ±Ÿ£º
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<vector<int>> ress;
        sort(nums.begin(),nums.end());
        backtrack(ress,{},nums,0);
        return ress;
    }
    void backtrack(vector<vector<int>> &ress,vector<int> res,vector<int> nums,int begin)
    {
        ress.push_back(res);
        int tmp;
        for(int j=begin;j<nums.size();j++)
        {
            if(j==begin||nums[j]!=nums[j-1])
            {
            res.push_back(nums[j]);
            backtrack(ress,res,nums,j+1);
            tmp=res.back();
            res.pop_back();
            }
        }
    }
};


method 2:Iterative
This problem can also be solved iteratively. Take [1, 2, 3] in the problem statement as an example. The process of generating all the subsets is like:

Initially: [[]]
Adding the first number to all the existed subsets: [[], [1]];
Adding the second number to all the existed subsets: [[], [1], [2], [1, 2]];
Adding the third number to all the existed subsets: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]].

class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> subs(1, vector<int>());
        for (int i = 0; i < nums.size(); i++) {
            int n = subs.size();
            for (int j = 0; j < n; j++) {
                subs.push_back(subs[j]); 
                subs.back().push_back(nums[i]);
            }
        }
        return subs;
    }
}; 

method 3:bit manipulation
This is the most clever solution that I have seen. The idea is that to give all the possible subsets, we just need to exhaust all the possible combinations of the numbers. And each number has only two possibilities: either in or not in a subset. And this can be represented using a bit.
There is also another a way to visualize this idea. That is, if we use the above example, 1 appears once in every two consecutive subsets, 2 appears twice in every four consecutive subsets, and 3 appears four times in every eight subsets, shown in the following (initially the 8 subsets are all empty):

[], [], [], [], [], [], [], []

[], [1], [], [1], [], [1], [], [1]

[], [1], [2], [1, 2], [], [1], [2], [1, 2]

[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]

The code is as follows.

class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int num_subset = pow(2, nums.size()); 
        vector<vector<int> > res(num_subset, vector<int>());
        for (int i = 0; i < nums.size(); i++)
            for (int j = 0; j < num_subset; j++)
                if ((j >> i) & 1)//µ±Ä³Ò»Î»Îª1±íÊŸÑ¡Ôñ¶ÔÓŠµÄÊý£¬Îª0±íÊŸ²»Ñ¡Ôñ¶ÔÓŠµÄÊý¡£
                    res[j].push_back(nums[i]);
        return res;  
    }
};




79. Word Search
method: backtrack
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        int m = board.size(), n = board[0].size();
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                if (search(board, i, j, word.c_str()))//use char* instead of string to speed up the code.
                    return true;
        return false;
    }
private: 
    bool search(vector<vector<char>>& board, int r, int c, const char* word) {
        if (!word[0]) return true;
        int m = board.size(), n = board[0].size();
        if (r < 0 || r >= m || c < 0 || c >= n || board[r][c] != word[0]) return false;
        board[r][c] = '$';
        if (search(board, r - 1 ,c, word + 1) || search(board, r + 1, c, word + 1) ||
            search(board, r, c - 1, word + 1) || search(board, r, c + 1, word + 1))
            return true;
        board[r][c] = word[0];
        return false;
    }
};



80. Remove Duplicates from Sorted Array II
my method:
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int count=0;
        for(int i=0;i<nums.size();i++)
        {
            if(i+2<nums.size()&&nums[i]==nums[i+2]) continue;
            nums[count++]=nums[i];
        }
        return count;
        
    }
};




81. Search in Rotated Sorted Array II
method:binary search
class Solution {
public:
    bool search(vector<int>& nums, int target) {
    int n=nums.size(),lo =0, hi = n-1;
    int mid = 0;
    while(lo<hi){
          mid=(lo+hi)/2;
          if(nums[mid]==target) return true;
          if(nums[mid]>nums[hi]){
              if(nums[mid]>target && nums[lo] <= target) hi = mid;
              else lo = mid + 1;
          }else if(nums[mid] < nums[hi]){
              if(nums[mid]<target && nums[hi] >= target) lo = mid + 1;
              else hi = mid;
          }else{
              hi--;
          }
          
    }
    return nums[lo] == target ? true : false;
    }
};



84. Largest Rectangle in Histogram
method:stack;eg:the left value 1 and the right value 2 should be smaller than the value 5 
1) Create an empty stack.

2) Start from first bar, and do following for every bar ¡®hist[i]¡¯ where ¡®i¡¯ varies from 0 to n-1.
¡­¡­a) If stack is empty or hist[i] is higher than the bar at top of stack, then push ¡®i¡¯ to stack.
¡­¡­b) If this bar is smaller than the top of stack, then keep removing the top of stack while top of the stack is greater. Let the removed bar be hist[tp]. Calculate area of rectangle with hist[tp] as smallest bar. For hist[tp], the ¡®left index¡¯ is previous (previous to tp) item in stack and ¡®right index¡¯ is ¡®i¡¯ (current index).

3) If the stack is not empty, then one by one remove all bars from stack and do step 2.b for every removed bar.

Following is C++ implementation of the above algorithm.

class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        stack<int> st;
        int i=0,maxarea=0;
        while(i<heights.size())
        {
            if(st.empty()||heights[i]>=heights[st.top()])
              st.push(i++);
            else
            {
                int tp=st.top();
                st.pop();
                maxarea=max(maxarea,heights[tp]*(st.empty()?i:i-st.top()-1));
            }
        }
        while(!st.empty())
        {
            int tp=st.top();
            st.pop();
            maxarea=max(maxarea,heights[tp]*(st.empty()?i:i-st.top()-1));
        }
        return maxarea;
    }
};


85. Maximal Rectangle
method:dp,stack
You can maintain a row length of Integer array H recorded its height of '1's, and scan and update row by row to find out the largest rectangle of each row.

For each row, if matrix[row][i] == '1'. H[i] +=1, or reset the H[i] to zero.
and accroding the algorithm of [Largest Rectangle in Histogram], to update the maximum area.

class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        int n=matrix.size(),maxarea=0;
        if(n==0) return 0;
        int m=matrix[0].size();
        vector<int> heights(m+1,0);//m+1  ×îºóÒ»žöžß¶ÈÒ»Ö±ÊÇ0
        
        for(int i=0;i<n;i++)
        {
            stack<int> st;
            for(int j=0;j<m+1;j++)
            {
                if(j<m)//²»žÄ×îºóÒ»žöžß¶È
                {
                    if(matrix[i][j]=='1') heights[j]+=1;
                    else heights[j]=0;
                }
                
                
                if(st.empty()||heights[j]>=heights[st.top()])
                  st.push(j);
                else
                {
                    while(!st.empty()&&heights[j]<heights[st.top()])
                    {
                        int tp=st.top();
                        st.pop();
                        maxarea=max(maxarea,heights[tp]*(st.empty()?j:j-st.top()-1));
                    }
                    st.push(j);//Òª°Ñj push
                }
            }
        }
        return maxarea;  
    }
};




87. Scramble String
method:recursive
class Solution {
public:
    bool isScramble(string s1, string s2) {
        if(s1==s2) return true;
        
        map<char,int> hs1,hs2;
        for(int i=0;i<s1.size();i++)
        {
            hs1[s1[i]]++;
            hs2[s2[i]]++;
        }
        if(hs1!=hs2) return false;
        
        int n=s1.size();
        for(int i=1;i<n;i++)
        {
            if(isScramble(s1.substr(0,i),s2.substr(0,i))&&isScramble(s1.substr(i),s2.substr(i)))
             return true;
            if(isScramble(s1.substr(0,i),s2.substr(n-i))&&isScramble(s1.substr(i),s2.substr(0,n-i)))
             return true;
        }
        return false;
    }
};




88. Merge Sorted Array
my method:two pointes
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i=0,j=0,size=m;//nums1ÖÐm~m+n¶ŒÎª0
        while(j<n&&i<size)
        {
            while(i<size&&nums2[j]>nums1[i]) i++;
            nums1.insert(nums1.begin()+i,nums2[j]);
            i++;j++;
            
            size++;
        }
        while(j!=n) nums1[i++]=nums2[j++];
        nums1.resize(m+n);//insertÖ»ÊÇœ«0ÍËºó£¬ÐèÒªŒôµôÎ²°ÍµÄ0
        
    }
};


89. Gray Code
my method 1:find the regular
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> res;
        res.push_back(0);
        for(int i=1;i<=n;i++)
        {
            for(int j=((1<<(i-1))-1);j>=0;j--)
            {
                res.push_back(res[j]+(1<<(i-1)));
            }
        }
        return res;
    }
    
};

method 2:bit
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> res;
        for(int i=0;i<1<<n;i++)
        {
            res.push_back(i^i>>1);
        }
        return res;
    }
    
};






90. Subsets II
my method £ºbacktrack
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<vector<int>> ress;
        sort(nums.begin(),nums.end());
        for(int k=0;k<=nums.size();k++)
        {
        backtrack(ress,k,{},nums,0);
        }
        return ress;
    }
    void backtrack(vector<vector<int>> &ress,int k,vector<int> res,vector<int> nums,int begin)
    {
        if(k==0)
        {
            ress.push_back(res);
            return;
        }
        int tmp;
        for(int j=begin;j<nums.size();j++)
        {
            if(j>0&&nums[j]==nums[j-1]&&res.back()!=nums[j]) continue;
            if(tmp&&tmp==nums[j]) continue;//ÁœžöÒÔÉÏµÄÖØžŽÊý×Ö
            res.push_back(nums[j]);
            backtrack(ress,k-1,res,nums,j+1);
            tmp=res.back();
            res.pop_back();
            
        }
    }
};




91. Decode Ways
method:dp
Áîdp[i]±íÊŸ×Ö·ûŽ®µÄÇ°ižö×Ö·ûµÄ¿ÉÄÜµÄ±àÂë·œÊœµÄÊýÁ¿¡£ÄÇÃŽµÝÍÆ¹«ÊœÈçÏÂ£º

Èç¹ûµ±Ç°Êý×ÖÎª0£¬ÔòÇ°ÃæÊý×Ö±ØÎª1»òÕß2£¬·ñÔòÎÞ·šœøÐÐ±àÂë×ª»»£¬ŽËÊ±µÄÊý×Ö0Ö»ÄÜºÍÇ°ÃæµÄ1»òÕß2Á¬ÔÚÒ»ÆðœøÐÐ±àÂë£¬ÒòŽËdp[i] = dp[i-2]£»
Èç¹ûÇ°ÃæÊý×ÖÎª1»òÕßÇ°ÃæÊý×ÖÎª2ÇÒµ±Ç°Êý×ÖÔÚ1~6Ö®Œä£¬ËµÃ÷¶Œ¿ÉÒÔœøÐÐ2ÖÖ±àÂë£š·Ö¿ª»òÕßºÍÔÚÒ»Æð£©£¬ÒòŽËdp[i] = dp[i-1] + dp[i-2]£»
ÆäËûÇé¿ö£¬µ±Ç°Êý×Ö±ØÐëµ¥¶ÀœøÐÐ±àÂë×ª»»£¬ÒòŽËdp[i] = dp[i-1]¡£

class Solution {
public:
    int numDecodings(string s) {
        int n=s.size();
        if(n==0) return 0;
        vector<int> dp(n+1);
        dp[0]=s[0]=='0'?0:1;
        dp[1]=dp[0];
        for(int i=1;i<n;i++)
        {
            if(s[i]=='0') 
            {
                if(s[i-1]=='1'||s[i-1]=='2')
                  dp[i+1]=dp[i-1];
                else return 0;//invalid encode
            }
            else if(s[i-1]=='1'||(s[i-1]=='2'&&s[i]<='6')) 
                dp[i+1]=dp[i]+dp[i-1];
            else 
                dp[i+1]=dp[i];
        }
        return dp[n];
    }
};




93. Restore IP Addresses
my method:backtrack
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {
        vector<string> ress;
        backtrack(ress,{},s,0,4);
        return ress;
    }
    void backtrack(vector<string> &ress,string res,string s,int begin,int k)
    {
        if(k==0&&begin==s.size())
        {
           // cout<<res;
            ress.push_back(res);
            return;
        }
        if(k==0&&begin<s.size()) return ;
        if(begin>=s.size()) return ;
        for(int i=begin;i<begin+3;i++)
        {
            string substrr=s.substr(begin,i-begin+1);
            if(substrr.size()==3&&substrr>"255")  continue;//²»ÏÞÖÆsizeµÄ»°£º"3">"225"
            if(s[begin]=='0'&&i-begin+1>1) continue;//²»ÄÜ³öÏÖ010ÕâÖÖ
            string tmp=res;
            if(k!=1)
            res+=substrr+".";
            else res+=substrr;
            //cout<<res<<endl;
            backtrack(ress,res,s,i+1,k-1);
            res=tmp;
        }
    }
};



95.Unique Binary Search Trees II
method 1:I start by noting that 1..n is the in-order traversal for any BST with nodes 1 to n. So if I pick i-th node as my root, the left subtree will contain elements 1 to (i-1), and the right subtree will contain elements (i+1) to n. I use recursive calls to get back all possible trees for left and right subtrees and combine them in all possible ways with the root.

class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        if(n==0) return {};
        return generate(1,n);
    }
    vector<TreeNode*> generate(int start,int end) 
    {
        vector<TreeNode*> res;
        if(start>end) 
        {
            res.push_back({});
            return res;//very important
        }
        if(start==end)
        {
            res.push_back(new TreeNode(start));
            return res;
        }
        for(int i=start;i<=end;i++)
        {
            vector<TreeNode*> left=generate(start,i-1);
            vector<TreeNode*> right=generate(i+1,end);
            for(TreeNode* l:left)
            for(TreeNode* r:right)
            {
                TreeNode* root=new TreeNode(i);
                root->left=l;
                root->right=r;
                res.push_back(root);
            }
        }
        return res;
    }
};

method 2:DP(what i didn't think is the function clone) java
public static List<TreeNode> generateTrees(int n) {
    List<TreeNode>[] result = new List[n + 1];
    result[0] = new ArrayList<TreeNode>();
    if (n == 0) {
        return result[0];
    }

    result[0].add(null);
    for (int len = 1; len <= n; len++) {
        result[len] = new ArrayList<TreeNode>();
        for (int j = 0; j < len; j++) {
            for (TreeNode nodeL : result[j]) {
                for (TreeNode nodeR : result[len - j - 1]) {
                    TreeNode node = new TreeNode(j + 1);
                    node.left = nodeL;
                    node.right = clone(nodeR, j + 1);
                    result[len].add(node);
                }
            }
        }
    }
    return result[n];
}

private static TreeNode clone(TreeNode n, int offset) {
    if (n == null) {
        return null;
    }
    TreeNode node = new TreeNode(n.val + offset);
    node.left = clone(n.left, offset);
    node.right = clone(n.right, offset);
    return node;
}



96.
my method:DP
class Solution {
public:
    int numTrees(int n) {
        vector<int> res(n+1,0);
        res[0]=1;
        res[1]=1;
        for(int i=2;i<=n;i++)
        {
            for(int j=0;j<i;j++)
            {
                res[i]+=res[j]*res[i-1-j];
            }
        }
        return res[n];
    }
};



97. Interleaving String
method:DP
s1, s2Ö»ÓÐÁœžö×Ö·ûŽ®£¬ÒòŽË¿ÉÒÔÕ¹ÆœÎªÒ»žö¶þÎ¬µØÍŒ£¬ÅÐ¶ÏÊÇ·ñÄÜŽÓ×óÉÏœÇ×ßµœÓÒÏÂœÇ¡£

µ±s1µœŽïµÚižöÔªËØ£¬s2µœŽïµÚjžöÔªËØ:

µØÍŒÉÏÍùÓÒÒ»²œŸÍÊÇs2[j-1]Æ¥Åäs3[i+j-1]¡£

µØÍŒÉÏÍùÏÂÒ»²œŸÍÊÇs1[i-1]Æ¥Åäs3[i+j-1]¡£

ÊŸÀý£ºs1="aa",s2="ab",s3="aaba"¡£±ê1µÄÎª¿ÉÐÐ¡£×îÖÕ·µ»ØÓÒÏÂœÇ¡£

     0  a  b

0   1  1  0

a   1  1  1

a   1  0  1


 int m = s1.size();
        int n = s2.size();
        if(m+n != s3.size())
            return false;
        vector<vector<bool> > path(m+1, vector<bool>(n+1, false));
        for(int i = 0; i < m+1; i ++)
        {
            for(int j = 0; j < n+1; j ++)
            {
                if(i == 0 && j == 0)
                // start
                    path[i][j] = true;
                else if(i == 0)
                    path[i][j] = path[i][j-1] & (s2[j-1]==s3[j-1]);
                else if(j == 0)
                    path[i][j] = path[i-1][j] & (s1[i-1]==s3[i-1]);
                else
                    path[i][j] = (path[i][j-1] & (s2[j-1]==s3[i+j-1])) || (path[i-1][j] & (s1[i-1]==s3[i+j-1]));
            }
        }
        return path[m][n];


98. Validate Binary Search Tree
my method :inorder pre<post
class Solution {
public:
TreeNode* pre=NULL;
    bool isValidBST(TreeNode* root) {
        if(root==NULL) return true;
        bool left=isValidBST(root->left);
        if(pre&&pre->val>=root->val) return false;
        pre=root;
        bool right=isValidBST(root->right);
        return left&&right;
    }
};


99. Recover Binary Search Tree
my method: inorder find the two node need to swap
class Solution {
public:
TreeNode* min=NULL,*max=NULL,*pre=NULL;
    void recoverTree(TreeNode* root) {
        find(root);
        int tmp=min->val;// not swap(min,max)
        min->val=max->val;
        max->val=tmp;
    }
    void find(TreeNode* root)
    {
        if(root==NULL) return;
        find(root->left);
        if(min==NULL&&pre&&pre->val>=root->val) min=pre;
        if(min&&pre&&pre->val>=root->val) max=root;
        pre=root;
        find(root->right);
    }
};


101.
method 1: recursive
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root==NULL) return true;
        
        return help(root->left,root->right);
    }
    bool help(TreeNode* left,TreeNode* right)
    {
        if(left==NULL||right==NULL) return left==right;
        if(left->val!=right->val) return false;
        return help(left->left,right->right)&& help(left->right,right->left);
    }

};

method 2 :queue
class Solution {
public:
    bool isSymmetric(TreeNode *root) {
        TreeNode *left, *right;
        if (!root)
            return true;
        
        queue<TreeNode*> q1, q2;
        q1.push(root->left);
        q2.push(root->right);
        while (!q1.empty() && !q2.empty()){
            left = q1.front();
            q1.pop();
            right = q2.front();
            q2.pop();
            if (NULL == left && NULL == right)
                continue;
            if (NULL == left || NULL == right)
                return false;
            if (left->val != right->val)
                return false;
            q1.push(left->left);
            q1.push(left->right);
            q2.push(right->right);
            q2.push(right->left);
        }
        return true;
    }
};


102. Binary Tree Level Order Traversal
My method 1: queue
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if(root==NULL) return {};
        queue<TreeNode*> q;
        q.push(root);
        int levelnum=1;
        vector<vector<int>> ress;
        
        while(!q.empty())
        {
            int count=0;
            vector<int> res;
            for(int i=0;i<levelnum;i++)
            {
                root=q.front();
                q.pop();
                res.push_back(root->val);
                if(root->left)
                {
                    q.push(root->left);
                    count++;
                }
                if(root->right)
                {
                    q.push(root->right);
                    count++;
                }
            }
            levelnum=count;
            ress.push_back(res);
        }
        return ress;
    }
};

method 2:preorder
class Solution {
public:
    vector<vector<int>> ress;
    vector<vector<int>> levelOrder(TreeNode* root) {
        if(root==NULL) return {};
        preOrder(root,0);
        return ress;
    }
    void preOrder(TreeNode* root,int depth)
    {
        if(root==NULL) return ;
        if(ress.size()==depth) ress.push_back(vector<int>());
        ress[depth].push_back(root->val);
        preOrder(root->left,depth+1);
        preOrder(root->right,depth+1);
    }
};


103.Binary Tree Zigzag Level Order Traversal
my method:
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        if(root==NULL) return {};
        queue<TreeNode*> q;
        q.push(root);
        int flag=0,level=1;
        vector<vector<int>> res;
        while(!q.empty())
        {
            int count=0;
            vector<int> tmp;
            for(int i=0;i<level;i++)
            {
                root=q.front();
                q.pop();
                if(root->left) 
                {
                    q.push(root->left);
                    count++;
                }
                if(root->right) 
                {
                    q.push(root->right);
                    count++;
                }
                if(flag==0)
                tmp.push_back(root->val);
                else
                tmp.insert(tmp.begin(),root->val);
            }
            res.push_back(tmp);
            level=count;
            flag=flag==0?1:0;
        }
        return res;
    }
};


105. Construct Binary Tree from Preorder and Inorder Traversal
my method :
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.size()==0) return NULL;
         //TreeNode* root=new TreeNode(preorder[0]);
        return build(preorder,inorder,0,preorder.size()-1,0,inorder.size()-1);
    }
    TreeNode* build(vector<int>& preorder, vector<int>& inorder,int ps,int pe,int is,int ie)
    {
        if(ie<is) return NULL;
        TreeNode* root=new TreeNode(preorder[ps]);
        int i=is;
        for(i=is;i<=ie;i++)
        {
            if(inorder[i]==root->val)
            break;
        }
        root->left= build(preorder,inorder,ps+1,ps+i-is,is,i-1);
        root->right=build(preorder,inorder,ps+i-is+1,pe,i+1,ie);
        return root;
    }
};


106.Construct Binary Tree from Inorder and Postorder Traversal
method :
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {
    return create(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);
}

TreeNode* create(vector<int> &inorder, vector<int> &postorder, int is, int ie, int ps, int pe){
    if(ps > pe){
        return nullptr;
    }
    TreeNode* node = new TreeNode(postorder[pe]);
    int pos;
    for(int i = is; i <= ie; i++){
        if(inorder[i] == node->val){
            pos = i;
            break;
        }
    }
    node->left = create(inorder, postorder, is, pos - 1, ps, ps + pos - is - 1);
    node->right = create(inorder, postorder, pos + 1, ie, pe - ie + pos, pe - 1);
    return node;
}
};



107.Binary Tree Level Order Traversal II
my method : level order traversal
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        if(!root) return {};
        vector<vector<int>> ress;
        
        int levelnum=1,level=0;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty())
        {
            vector<int> res;
            int count=0;
            for(int i=0;i<levelnum;i++)
            {
                root=q.front();
                q.pop();
                res.push_back(root->val);
                if(root->left)
                {
                    q.push(root->left);
                    count++;
                }
                if(root->right)
                {
                    q.push(root->right);
                    count++;
                }
            }
            levelnum=count;
            ress.insert(ress.begin(),res);
        }
       
       
        return ress;
        
    }
};


108.Convert Sorted Array to Binary Search Tree
method£ºµÝ¹é£¬Ã¿ŽÎ°ÑÖÐŒäµÄ×÷ÎªžùœÚµã£¬×ó×ÓÊ÷Îª×ó±ß²¿·Ö£¬ÓÒ×ÓÊ÷ÎªÓÒ±ß²¿·Ö
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        if(nums.size()==0) return NULL;
        return toBst(nums,0,nums.size()-1);
    }
    TreeNode* toBst(vector<int> nums,int left,int right)
    {
        if(left>right) return NULL;
        int middle=(right+left)/2;//not "-"
        TreeNode* root=new TreeNode(nums[middle]);
        root->left=toBst(nums,left,middle-1);
        root->right=toBst(nums,middle+1,right);
        return root;
        
        
    }
};

109. Convert Sorted List to Binary Search Tree
my method :
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        if(head==NULL) return NULL;
        if(head->next==NULL) return new TreeNode(head->val);
        int count=0;
        ListNode* cur=head,*pre=head;
        while(cur)
        {
            cur=cur->next;
            count++;
        }
        cur=head;
        count=count/2;
        while(count-->0)
        {
            pre=cur;
            cur=cur->next;
        }
        pre->next=NULL;
        TreeNode* root=new TreeNode(cur->val);
        root->left=sortedListToBST(head);
        root->right=sortedListToBST(cur->next);
        return root;
    }
    
};


110. Balanced Binary Tree
my method 1:
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if(root==NULL) return true;
        if(abs(height(root->left)-height(root->right))>1)  return false;
        return isBalanced(root->left)&&isBalanced(root->right);
    }
    int height(TreeNode* root)
    {
        if(root==NULL) return 0;
        return max(height(root->left),height(root->right))+1;
    }
};

For the current node root, calling depth() for its left and right children actually has to access all of its children, thus the complexity is O(N). We do this for each node in the tree, so the overall complexity of isBalanced will be O(NlogN). This is a top down approach.

method 2:
The second method is based on DFS. Instead of calling depth() explicitly for each child node, we return the height of the current node in DFS recursion. When the sub tree of the current node (inclusive) is balanced, the function dfsHeight() returns a non-negative value as the height. Otherwise -1 is returned. According to the leftHeight and rightHeight of the two children, the parent node could check if the sub tree
is balanced, and decides its return value.

class solution {
public:
int dfsHeight (TreeNode *root) {
        if (root == NULL) return 0;
        
        int leftHeight = dfsHeight (root -> left);
        if (leftHeight == -1) return -1;
        int rightHeight = dfsHeight (root -> right);
        if (rightHeight == -1) return -1;
        
        if (abs(leftHeight - rightHeight) > 1)  return -1;
        return max (leftHeight, rightHeight) + 1;
    }
    bool isBalanced(TreeNode *root) {
        return dfsHeight (root) != -1;
    }
};
In this bottom up approach, each node in the tree only need to be accessed once. Thus the time complexity is O(N), better than the first solution.


111. Minimum Depth of Binary Tree
my method 1:
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root==NULL) return 0;
        int left=INT_MAX,right=INT_MAX;//for those not leaf node
        if(root->left) 
        left=minDepth(root->left);
        if(root->right) 
        right=minDepth(root->right);
        if(root->left||root->right)
        return min(left,right)+1;
        else
        return 1;
    }
};
method 2:
public class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        int left = minDepth(root.left);
        int right = minDepth(root.right);
        return (left == 0 || right == 0) ? left + right + 1: Math.min(left,right) + 1;
       
    }
}


112. Path Sum
my method 1: need o(n) space
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        vector<int> res;
       preOrder(root,0,res);
       for(int i=0;i<res.size();i++)
       {
           if(res[i]==sum)
           return true;
       }
       return false;
    }
    void preOrder(TreeNode* root,int sum,vector<int> &res)
    {
        if(root==NULL) return ;
        sum=sum+root->val;
        if(root->left==NULL&&root->right==NULL)
        res.push_back(sum);
        preOrder(root->left,sum,res);
        preOrder(root->right,sum,res);
    }
};

method 2;
public class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null) return false;
    
        if(root.left == null && root.right == null && sum - root.val == 0) return true;
    
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }
}

113.
my method :
class Solution {
public:
    vector<vector<int>> pathSum(TreeNode* root, int sum) {
        if(root==NULL) return {};
        vector<vector<int>> res;
        preOrder(root,sum,{},res);
        return res;
    }
    void preOrder(TreeNode* root,int sum,vector<int> vec,vector<vector<int>> &res)
    {
        if(root==NULL) return ;
        vec.push_back(root->val);
        if(root->left==NULL&&root->right==NULL&&root->val-sum==0)
        res.push_back(vec);
        preOrder(root->left,sum-root->val,vec,res);
        preOrder(root->right,sum-root->val,vec,res);
    }
};

114. Flatten Binary Tree to Linked List
method 1: reverse preorder
class Solution {
public:
    TreeNode* pre=NULL;
    void flatten(TreeNode* root) {
        if(root==NULL) return;
        flatten(root->right);
        flatten(root->left);
        root->right=pre;
        root->left=NULL;
        pre=root;
    }
};

method 2: straighted
class Solution {
public:
    void flatten(TreeNode *root) {
		TreeNode*now = root;
		while (now)
		{
			if(now->left)
			{
                //Find current node's prenode that links to current node's right subtree
				TreeNode* pre = now->left;
				while(pre->right)
				{
					pre = pre->right;
				}
				pre->right = now->right;
                //Use current node's left subtree to replace its right subtree(original right 
                //subtree is already linked by current node's prenode
				now->right = now->left;
				now->left = NULL;
			}
			now = now->right;
		}
    }
};



115.Distinct Subsequences
method:DP
The idea is the following:

we will build an array mem where mem[i+1][j+1] means that S[0..j] contains T[0..i] that many times as distinct subsequences. Therefor the result will be mem[T.length()][S.length()].
we can build this array rows-by-rows:
the first row must be filled with 1. That's because the empty string is a subsequence of any string but only 1 time. So mem[0][j] = 1 for every j. So with this we not only make our lives easier, but we also return correct value if T is an empty string.
the first column of every rows except the first must be 0. This is because an empty string cannot contain a non-empty string as a substring -- the very first item of the array: mem[0][0] = 1, because an empty string contains the empty string 1 time.
So the matrix looks like this:

  S 0123....j
T +----------+
  |1111111111|
0 |0         |
1 |0         |
2 |0         |
. |0         |
. |0         |
i |0         |
From here we can easily fill the whole grid: for each (x, y), we check if S[x] == T[y] we add the previous item and the previous item in the previous row, otherwise we copy the previous item in the same row. The reason is simple:

if the current character in S doesn't equal to current character T, then we have the same number of distinct subsequences as we had without the new character.
if the current character in S equal to the current character T, then the distinct number of subsequences: the number we had before plus the distinct number of subsequences we had with less longer T and less longer S.
An example:
S: [acdabefbc] and T: [ab]

first we check with a:

           *  *
      S = [acdabefbc]
mem[1] = [0111222222]
then we check with ab:

               *  * ]
      S = [acdabefbc]
mem[1] = [0111222222]
mem[2] = [0000022244]
(ÉèŸØÕótransArray£¬ÆäÖÐÔªËØtransArray[i][j]ÎªS[0,...,i]µœT[0,...,j]ÓÐ¶àÉÙÖÖ×ª»»·œÊœ¡£

ÎÊÌâŸÍ×ªÎªŽÓ×óÉÏœÇÖ»ÄÜ×ß¶ÔœÇ£šÆ¥Åä£©»òÕßÍùÏÂ£šÉŸ³ý×Ö·û£©£¬µœÓÒÏÂœÇÒ»¹²ÓÐ¶àÉÙÖÖ×ß·š¡£

transArray[i][0]³õÊŒ»¯Îª1µÄº¬ÒåÊÇ£ºÈÎºÎ³€¶ÈµÄS£¬Èç¹û×ª»»Îª¿ÕŽ®£¬ÄÇŸÍÖ»ÓÐÉŸ³ýÈ«²¿×Ö·ûÕâ1ÖÖ·œÊœ¡£

µ±S[i-1]==T[j-1]£¬ËµÃ÷¿ÉÒÔŽÓtransArray[i-1][j-1]×ß¶ÔœÇµœŽïtransArray[i][j]£šS[i-1]Æ¥ÅäT[j-1]£©£¬ŽËÍâ»¹¿ÉÒÔŽÓtransArray[i-1][j]ÍùÏÂµœŽïtransArray[i][j]£šÉŸ³ýS[i-1]£©

µ±S[i-1]!=T[j-1]£¬ËµÃ÷Ö»ÄÜŽÓtransArray[i-1][j]ÍùÏÂµœŽïtransArray[i][j]£šÉŸ³ýS[i-1]£©)

class Solution {
public:
    int numDistinct(string s, string t) {
        vector<vector<int>> dp(t.size()+1,vector<int>(s.size()+1,0));
        for(int j=0;j<=s.size();j++)
        {
            dp[0][j]=1;
        }
        for(int i=1;i<=t.size();i++)
        for(int j=1;j<=s.size();j++)
        {
            if(s[j-1]==t[i-1])
             dp[i][j]=dp[i-1][j-1]+dp[i][j-1];
            else
             dp[i][j]=dp[i][j-1];
        }
        return dp[t.size()][s.size()];
    
    }
};



116.
my method 1: Öð²ã±éÀú

/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connect(TreeLinkNode *root) {
        if(!root) return ;
        queue<TreeLinkNode *> q;
        q.push(root);
        int levelnum=1;
        while(!q.empty())
        {
            TreeLinkNode * tmp=NULL;
            for(int i=0;i<levelnum;i++)
            {
                root=q.front();
                q.pop();
                if(root->left) q.push(root->left);
                if(root->right)q.push(root->right);
                if(i!=0)
                tmp->next=root;
                tmp=root;
            }
            levelnum*=2;
        }
        return ;
    }
};

method 2: two pointers ; use constant extra space.
void connect(TreeLinkNode *root) {
    if (root == NULL) return;
    TreeLinkNode *pre = root;
    TreeLinkNode *cur = NULL;
    while(pre->left) {
        cur = pre;
        while(cur) {
            cur->left->next = cur->right;
            if(cur->next) cur->right->next = cur->next->left;
            cur = cur->next;
        }
        pre = pre->left;
    }
}


117. Populating Next Right Pointers in Each Node II

my method 1:
/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connect(TreeLinkNode *root) {
        TreeLinkNode * cur=root ,*pre=root;
        while(pre)
        {
            if(pre->left) pre=pre->left;
            else if(pre->right) pre=pre->right;
            else {
                while(pre&&!(pre->left||pre->right))
                pre=pre->next;
                if(pre&&pre->left) pre=pre->left;
                else if(pre&&!pre->left&&pre->right) pre=pre->right;
                else {pre=NULL;return;}
            }
        while(cur)
        {
             
            if(cur->left&&cur->right) 
            {cur->left->next=cur->right;
            
            }
            if(cur->next)
            {
            TreeLinkNode * tmp=cur->next;
            while(tmp&&!(tmp->left||tmp->right)) tmp=tmp->next;
            if(tmp)
            {
            if(cur->left&&!cur->right&&tmp->left) cur->left->next=tmp->left;
            if(cur->left&&!cur->right&&!tmp->left&&tmp->right) cur->left->next=tmp->right;
            if(cur->right&&tmp->left) cur->right->next=tmp->left;
            if(cur->right&&!tmp->left&&tmp->right) cur->right->next=tmp->right;
            }
            }
            cur=cur->next;
        }
        cur=pre;
        }
        
    }
};

method 2: ÓÃprevŒÇÂŒÇ°Ò»žöcurµÄ×ÓœÚµãÖÐÎŽÁ¬œÓµÄÇ°Ò»žöœÚµã
public class Solution {
    
    //based on level order traversal
    public void connect(TreeLinkNode root) {

        TreeLinkNode head = null; //head of the next level
        TreeLinkNode prev = null; //the leading node on the next level
        TreeLinkNode cur = root;  //current node of current level

        while (cur != null) {
            
            while (cur != null) { //iterate on the current level
                //left child
                if (cur.left != null) {
                    if (prev != null) {
                        prev.next = cur.left;
                    } else {
                        head = cur.left;
                    }
                    prev = cur.left;
                }
                //right child
                if (cur.right != null) {
                    if (prev != null) {
                        prev.next = cur.right;
                    } else {
                        head = cur.right;
                    }
                    prev = cur.right;
                }
                //move to next node
                cur = cur.next;
            }
            
            //move to next level
            cur = head;
            head = null;
            prev = null;
        }
        
    }
}



118. Pascal's Triangle
my method:
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        if(numRows==0) return {};
        vector<vector<int>> res(numRows,vector<int>());
        res[0].push_back(1);
        for(int i=1;i<numRows;i++)
        {
            res[i].push_back(1);
            for(int j=1;j<res[i-1].size();j++)
            {
                res[i].push_back(res[i-1][j]+res[i-1][j-1]);
            }
            res[i].push_back(1);
        }
        return res;
        
        
    }
};



119. Pascal's Triangle II
my method:
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        if(rowIndex==0) return {1};
        vector<int> res={1,1},tmp;
        for(int i=2;i<=rowIndex;i++)
        {
            tmp.push_back(1);
            for(int j=1;j<res.size();j++)
            {
                tmp.push_back(res[j]+res[j-1]);
            }
            tmp.push_back(1);
            res=tmp;
            tmp.clear();
        }
        return res;
    }
};

method 2:o(k) space
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> res(rowIndex+1,0);
        res[0]=1;
        for(int i=1;i<=rowIndex;i++)
        {
            for(int j=i;j>=0;j--)
            {
                res[j]+=res[j-1];
            }
        }
        return res;
    }
};



120. Triangle
my method:DP
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        if(triangle.size()==0) return 0;
        vector<int> res(triangle.size(),0);//present the minsum to the point
        res[0]=triangle[0][0];
        int minsum=INT_MAX;
        for(int i=1;i<triangle.size();i++)
        {
            for(int j=triangle[i].size()-1;j>=0;j--)
            {
                if(j==triangle[i].size()-1)
                res[j]=res[j-1]+triangle[i][j];
                else if(j==0) res[j]=res[j]+triangle[i][j];
                else res[j]=min(res[j-1],res[j])+triangle[i][j];
                if(i==triangle.size()-1) minsum=min(minsum,res[j]);
            }
            
        }
        return minsum==INT_MAX?res[0]:minsum;
    }
};



121. Best Time to Buy and Sell Stock
my method: calculate the max sell price then 
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int max=0;
        int maxpro=0;
        for(int i=prices.size()-1;i>=0;i--)
        {
            maxpro=maxpro>(max-prices[i])?maxpro:max-prices[i];
            if(max<prices[i]) max=prices[i];
        }
        return maxpro;
    }
};
method 2:calculate the min buy price
int maxProfit(vector<int> &prices) {
    int maxPro = 0;
    int minPrice = INT_MAX;
    for(int i = 0; i < prices.size(); i++){
        minPrice = min(minPrice, prices[i]);
        maxPro = max(maxPro, prices[i] - minPrice);
    }
    return maxPro;
}


122. Best Time to Buy and Sell Stock II
method:suppose the first sequence is "a <= b <= c <= d", the profit is "d - a = (b - a) + (c - b) + (d - c)" without a doubt. And suppose another one is "a <= b >= b' <= c <= d", the profit is not difficult to be figured out as "(b - a) + (d - b')". So you just target at monotone sequences.
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size()==0) return 0;
        int maxpro=0;
        for(int i=0;i<prices.size()-1;i++)
        {
            if(prices[i+1]>prices[i]) maxpro+=prices[i+1]-prices[i];
        }
        return maxpro;
    }
};



123. Best Time to Buy and Sell Stock III
method :DP
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // f[k, i] represents the max profit up until prices[ii] (Note: NOT ending with prices[i]) using at most k transactions. 
        // f[k, i] = max(f[k, i-1], prices[i] - prices[j] + f[k-1, j]) {j in range of [0, ii-1] }
        //          = max(f[k, i-1], prices[i] + max(f[k-1, j] - prices[j]))
        // f[0, i] = 0; 0 times transation makes 0 profit
        // f[k, 0] = 0; if there is only one price data point you can't make any money no matter how many times you can trade
        int len=prices.size();
        if(len<=1) return 0;
        int k=2;
        vector<vector<int>> res(k+1,vector<int>(len,0));
        for(int i=1;i<=k;i++)
        {
            int tmpmax=-prices[0];
            for(int j=1;j<len;j++)
            {
                res[i][j]=max(res[i][j-1],tmpmax+prices[j]);
                tmpmax=max(tmpmax,res[i-1][j]-prices[j]);
            }
            
        }
        return res[k][len-1];
    }
};




124. Binary Tree Maximum Path Sum
method :A path from start to end, goes up on the tree for 0 or more steps, then goes down for 0 or more steps. Once it goes down, it can't go up. Each path has a highest node, which is also the lowest common ancestor of all other nodes on the path.
A recursive method maxPathDown(TreeNode node) (1) computes the maximum path sum with highest node is the input node, update maximum if necessary (2) returns the maximum sum of the path that can be extended to input node's parent.

class Solution {
public:
int maxvalue;
    int maxPathSum(TreeNode* root) {
        maxvalue=INT_MIN;
        pathDown(root);
        return maxvalue;
        
    }
    int pathDown(TreeNode* root)
    {
        if(root==NULL) return 0;
        int left=max(0,pathDown(root->left));
        int right=max(0,pathDown(root->right));
        maxvalue=max(maxvalue,left+right+root->val);
        return max(left,right)+root->val; //important!!
    }

    
};



125. Valid Palindrome
method:two pointers
class Solution {
public:
    bool isPalindrome(string s) {
        for (int i = 0, j = s.size() - 1; i < j; i++, j--) { // Move 2 pointers from each end until they collide
        while (isalnum(s[i]) == false && i < j) i++; // Increment left pointer if not alphanumeric
        while (isalnum(s[j]) == false && i < j) j--; // Decrement right pointer if no alphanumeric
        if (toupper(s[i]) != toupper(s[j])) return false; // Exit and return error if not match
    }
    
    return true;
    }
};



129.
my method 1: preorder
class Solution {
public:
vector<int> res;
    int sumNumbers(TreeNode* root) {
        preOrder(root,0,0);
        int sum=0;
        for(int i=0;i<res.size();i++)
        {
            sum+=res[i];
        }
        return sum;
    }
    void preOrder(TreeNode* root,int depth,int sum)
    {
        if(root==NULL) return;
        sum=sum*10+root->val;
        if(root->left==NULL&&root->right==NULL) //×¢ÒâÕâžö
        {
            res.push_back(sum);
            return;
        }
        preOrder(root->left,depth+1,sum);
        preOrder(root->right,depth+1,sum);
    }
};

method 2: java 
public int sumNumbers(TreeNode root) {
	return sum(root, 0);
}

public int sum(TreeNode n, int s){
	if (n == null) return 0;
	if (n.right == null && n.left == null) return s*10 + n.val;
	return sum(n.left, s*10 + n.val) + sum(n.right, s*10 + n.val);
}



131. Palindrome Partitioning
method:backtrack
class Solution {
public:
    vector<vector<string>> partition(string s) {
        vector<vector<string>> ress;
        backtrack(ress,{},s,0);
        return ress;
        
    }
    void backtrack(vector<vector<string>> &ress,vector<string> res,string s,int begin)
    {
        if(begin==s.size())
        {
            ress.push_back(res);
            return;
        }
        for(int i=begin;i<s.size();i++)//iÎª×ÖŽ®³€¶È
        {
            if(!isPalindrome(s.substr(begin,i-begin+1))) continue;
            res.push_back(s.substr(begin,i-begin+1));
            backtrack(ress,res,s,i+1);
            res.pop_back();
        }
    }
    bool isPalindrome(string s)
    {
        int i=s.size()-1,j=0;
        while(j<i)
        {
            if(s[i]!=s[j]) return false;
            i--;
            j++;
        }
        return true;
    }
};



132. Palindrome Partitioning II
method 1:
class Solution {
public:
    int minCut(string s) {
        int n=s.size();
        vector<vector<bool>> pal(n,vector<bool>(n,false));//i~j of s is palindrome or not
        vector<int> dp(n);
        for(int i=n-1;i>=0;i--)
        {
            dp[i]=n-1-i;
            for(int j=i;j<n;j++)
            {
                if(s[i]==s[j]&&(j-i<2||pal[i+1][j-1]))
                {
                    pal[i][j]=true;
                    if(j==n-1) dp[i]=0;
                    else dp[i]=min(dp[i],dp[j+1]+1);
                }
            }
        }
        return dp[0];
        
    }
};

method 2:o(n)space;13ms
class Solution {
public:
    int minCut(string s) {
        int n=s.size();
        vector<int> dp(n+1,0);
        for(int i=0;i<=n;i++) dp[i]=i-1;
        for(int i=0;i<n;i++)
        {
            for(int j=0;i-j>=0&&i+j<n&&s[i-j]==s[i+j];j++)//s[i] as center ;odd length palindrome
               dp[i+j+1]=min(dp[i-j]+1,dp[i+j+1]);
               
            for(int j=1;i-j+1>=0&&i+j<n&&s[i-j+1]==s[i+j];j++)//even length palindrome
               dp[i+j+1]=min(dp[i-j+1]+1,dp[i+j+1]);
        }
        return dp[n];
        
    }
};



133. Clone Graph
method:dfs
/**
 * Definition for undirected graph.
 * struct UndirectedGraphNode {
 *     int label;
 *     vector<UndirectedGraphNode *> neighbors;
 *     UndirectedGraphNode(int x) : label(x) {};
 * };
 */
class Solution {
public:
   map<UndirectedGraphNode*, UndirectedGraphNode*> hash;
    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
        if(node==NULL) return NULL;
        if(hash.find(node)==hash.end())//avoid repeat
        {
        UndirectedGraphNode *head=new UndirectedGraphNode(node->label);
        hash[node]=head;
        for(UndirectedGraphNode *cur:node->neighbors)
        {
            if(cur->label==head->label) head->neighbors.push_back(head);
            else
            head->neighbors.push_back(cloneGraph(cur));
        }
        }
        return hash[node];
    }
};



134. Gas Station
my method:
The main idea is that every time we go to the next station as far as possible (remained gas is bigger or equal to 0) until we can not (remained gas is less than 0).
Then we must extend our start station to the "last station" ( the station before start station) to find a possible solution.
Repeat these two steps until we have checked all stations(start == end).

class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int s=0;
        for(int i=0;i<gas.size();i++)
        {
            s+=gas[i]-cost[i];
        }
        if(s<0) return -1;
        int start=-1,cur,sum;
        for(int i=0;i<gas.size();i++)
        {
            if(gas[i]>=cost[i])
            {
                start=i;
                cur=i+1,sum=gas[i]-cost[i];
                if(cur==gas.size()) cur=0;
                while(start<gas.size()&&cur!=start)
                {
                    if(sum<0) break;
                    else
                    {
                        sum+=gas[cur]-cost[cur];
                        cur++;
                        if(cur==gas.size()) cur=0;
                    }
                }
                if(cur==start) return start; 
                i=cur-1;//Žý»á»¹Òªi++
            }
        }
        return -1;
    }
};

method 2:
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int start=gas.size()-1,end=0,sum=gas[start]-cost[start];
        while(end<start)
        {
            if(sum>=0)
            {
                sum+=gas[end]-cost[end];
                end++;
            }
            else
            {
                start--;
                sum+=gas[start]-cost[start];
            }
        }
        return sum>=0?start:-1;
    }
};



137. Single Number II
method 1: int ÊýŸÝ¹²ÓÐ32Î»£¬¿ÉÒÔÓÃ32±äÁ¿ŽæŽ¢ Õâ N žöÔªËØÖÐž÷žö¶þœøÖÆÎ»ÉÏ  1  ³öÏÖµÄŽÎÊý£¬×îºó ÔÚœøÐÐ Ä£Èý ²Ù×÷£¬Èç¹ûÎª1£¬ÄÇËµÃ÷ÕâÒ»Î»ÊÇÒªÕÒÔªËØ¶þœøÖÆ±íÊŸÖÐÎª 1 µÄÄÇÒ»Î»¡£
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res[32]={0},sum=0;
        for(int j=0;j<32;j++)
        {
        for(int i=0;i<nums.size();i++)
        {
            if((nums[i]>>j)&1)
            res[j]++;
        }
        sum|=(res[j]%3)<<j;
        }
        return sum;
    }
};
method 2:
ones   Žú±íµÚith Î»Ö»³öÏÖÒ»ŽÎµÄÑÚÂë±äÁ¿
twos  Žú±íµÚith Î»Ö»³öÏÖÁœŽÎŽÎµÄÑÚÂë±äÁ¿
threes  Žú±íµÚith Î»Ö»³öÏÖÈýŽÎµÄÑÚÂë±äÁ¿
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ones=0,twos=0,three=0;
        for(int i=0;i<nums.size();i++)
        {
            twos|=ones&nums[i];
            ones^=nums[i];
            ///¶ÔÓÚones ºÍ twos °Ñ³öÏÖÁË3ŽÎµÄÎ»ÖÃÉèÖÃÎª0 £šÈ¡·ŽÖ®ºó1µÄÎ»ÖÃÎª0£©
            three=ones&twos;
            ones&=~three;
            twos&=~three;
        }
        return ones;
    }
};



138. Copy List with Random Pointer
method 1:hashtable; just create all nodes and put <old, new> pairs into a map. Then update next and random pointers for each new node.

/**
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     RandomListNode *next, *random;
 *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:
    RandomListNode *copyRandomList(RandomListNode *head) {
       if(head==NULL) return NULL;
       map<RandomListNode *,RandomListNode *> hs;
       RandomListNode *cur=head;
       while(cur)
       {
           hs[cur]=new RandomListNode(cur->label);
           cur=cur->next;
       }
       cur=head;
       map<RandomListNode *,RandomListNode *>::iterator it;
       for(it=hs.begin();it!=hs.end();it++)
       {
           if(it->first->next)it->second->next=(hs.find(it->first->next))->second;
           if(it->first->random) it->second->random=(hs.find(it->first->random))->second;
       }
       return (hs.find(head))->second;
    
    }
};

method 2:The algorithm is composed of the follow three steps which are also 3 iteration rounds.
.Iterate the original list and duplicate each node. The duplicate of each node follows its original immediately.
.Iterate the new list and assign the random pointer for each duplicated node.
.Restore the original list and extract the duplicated nodes.

/**
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     RandomListNode *next, *random;
 *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:
    RandomListNode *copyRandomList(RandomListNode *head) {
        RandomListNode *next,*cur=head;
       // First round: make copy of each node,
	   // and link them together side-by-side in a single list.
        while(cur)
        {
            next=cur->next;
            RandomListNode* copy=new RandomListNode(cur->label);
            copy->next=next;
            cur->next=copy;
            cur=next;
        }
        // Second round: assign random pointers for the copy nodes.
        cur=head;
        while(cur)
        {
            if(cur->random)
                cur->next->random=cur->random->next;
            cur=cur->next->next;
        }
        // Third round: restore the original list, and extract the copy list.
        cur=head;
        RandomListNode * copyhead=new RandomListNode(0),*copycur=copyhead,*copynext;
        while(cur)
        {
            next=cur->next->next;
            copynext=cur->next;
            cur->next=next;
            copycur->next=copynext;
            cur=next;
            copycur=copynext;
        }
         return copyhead->next;
    
    }
};



139. Word Break
method:DP(backtrack lead to TLE)
class Solution {
public:
    bool wordBreak(string s, unordered_set<string>& wordDict) {
        int n=s.size();
       vector<bool> dp(n+1,false);
       dp[0]=true;
       for(int i=0;i<n;i++)
       {
           for(int j=i;j>=0;j--)
           {
               if(!dp[j]) continue;
               if(wordDict.find(s.substr(j,i-j+1))!=wordDict.end())
               {
                   dp[i+1]=true;
                   break;
               }
           }
       }
       return dp[n];
    }
};



140. Word Break II
method: DP;backtrack
class Solution {
public:
    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {
        int n=s.size();//check if s can be breaked
       vector<bool> dp(n+1,false);
       dp[0]=true;
       for(int i=0;i<n;i++)
       {
           for(int j=i;j>=0;j--)
           {
               if(!dp[j]) continue;
               if(wordDict.find(s.substr(j,i-j+1))!=wordDict.end())
               {
                   dp[i+1]=true;
                   break;
               }
           }
       }
       if(!dp[n]) return {};
        vector<string> ress;//break
        backtrack(ress,{},s,wordDict,0);
        return ress;
    }
    void backtrack(vector<string> &ress,string res,string s,unordered_set<string> wordDict,int begin)
    {
        if(begin==s.size())
        {
            res.erase(res.size()-1);
            ress.push_back(res);
            return;
        }
        for(int i=begin;i<s.size();i++)
        {
            if(wordDict.find(s.substr(begin,i-begin+1))==wordDict.end()) continue;
            string tmp=res;
            res+=s.substr(begin,i-begin+1)+" ";
            backtrack(ress,res,s,wordDict,i+1);
            res=tmp;
        }
    }
};



143. Reorder List
my method:
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void reorderList(ListNode* head) {
        if(!head||!head->next||!head->next->next) return ;
        ListNode* p=head,*q=head,*ptmp;
        while(q&&q->next)//find the middle
        {
            q=q->next->next;
            p=p->next;
        }
        ptmp=p;
        p=p->next;
        ListNode* post,*tmp;
        ptmp->next=NULL;
        if(p) post=p->next;
        p->next=NULL;
        while(post)//reverse the post half
        {
            tmp=post->next;
            post->next=p;
            p=post;
            post=tmp;
        }
        //insert
        q=head;
        ListNode* postq=q->next,*postp=p->next;
        while(p)
        {
            q->next=p;
            p->next=postq;
            q=postq;
            postq=postq->next;
            p=postp;
            if(postp) postp=postp->next;
        }
        return ;
        
        
    }
};



145.
my method 1: recursive
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        post(root,res);
        return res;
    }
    void post(TreeNode* root,vector<int> &res)
    {
        if(root==NULL) return ;
        post(root->left,res);
        post(root->right,res);
        res.push_back(root->val);
    }
};

my method2:
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        if(!root) return {};
        vector<int> res;
        stack<TreeNode*> s;
        while(root)
        {
            s.push(root);
            while(root->left)
            {
                root=root->left;
                s.push(root);
            }
            root=s.top();
            TreeNode* tmp=NULL;
            while((!root->right||root->right==tmp)&&!s.empty())
            {
                res.push_back(root->val);
                tmp=root;
                s.pop();
                if(!s.empty())
                root=s.top();
                else
                {
                return res;
                }
            }
            if(root)
            root=root->right;
        }
    
        return res;
    }

};

method 3:
pre-order traversal is root-left-right, and post order is left-right-root. modify the code for pre-order to make it root-right-left, and then reverse the output so that we can get left-right-root .

Create an empty stack, Push root node to the stack.
Do following while stack is not empty.
2.1. pop an item from the stack and print it.

2.2. push the left child of popped item to stack.

2.3. push the right child of popped item to stack.

reverse the ouput.

class Solution {
public:
    vector<int> postorderTraversal(TreeNode *root) {
        stack<TreeNode*> nodeStack;
        vector<int> result;
        //base case
        if(root==NULL)
        return result;
        nodeStack.push(root);
    while(!nodeStack.empty())
    {
        TreeNode* node= nodeStack.top();  
        result.push_back(node->val);
        nodeStack.pop();
        if(node->left)
        nodeStack.push(node->left);
        if(node->right)
        nodeStack.push(node->right);
    }
     reverse(result.begin(),result.end());
     return result;
    
}
};



148. Sort List
method :
 ¶ÔÒ»žöÁŽ±íœøÐÐÅÅÐò£¬ÇÒÊ±ŒäžŽÔÓ¶ÈÒªÇóÎª O(n log n) £¬¿ÕŒäžŽÔÓ¶ÈÎª³£Á¿¡£Ò»¿Žµœ O(n log n) µÄÅÅÐò£¬Ê×ÏÈÓŠžÃÏëµœ¹é²¢ÅÅÐòºÍ¿ìËÙÅÅÐò£¬µ«ÊÇÍš³£ÎÒÃÇÊ¹ÓÃÕâÁœÖÖÅÅÐò·œ·šÊ±¶ŒÊÇÕë¶ÔÊý×éµÄ£¬ÏÖÔÚÊÇÁŽ±íÁË¡£
 ¹é²¢ÅÅÐò·š£ºÔÚ¶¯ÊÖÖ®Ç°Ò»Ö±ŸõµÃ¿ÕŒäžŽÔÓ¶ÈÎª³£Á¿²»Ì«¿ÉÄÜ£¬ÒòÎªÔ­ÀŽÊ¹ÓÃ¹é²¢Ê±£¬¶ŒÊÇ O(N)µÄ£¬ÐèÒªžŽÖÆ³öÏàµÈµÄ¿ÕŒäÀŽœøÐÐž³Öµ¹é²¢¡£¶ÔÓÚÁŽ±í£¬ÊµŒÊÉÏÊÇ¿ÉÒÔÊµÏÖ³£Êý¿ÕŒäÕŒÓÃµÄ¡£ÀûÓÃ¹é²¢µÄËŒÏë£¬µÝ¹éµØœ«µ±Ç°ÁŽ±í·ÖÎªÁœ¶Î£¬È»ºómerge£¬·ÖÁœ¶ÎµÄ·œ·šÊÇÊ¹ÓÃ fast-slow ·š£¬ÓÃÁœžöÖžÕë£¬Ò»žöÃ¿ŽÎ×ßÁœ²œ£¬Ò»žö×ßÒ»²œ£¬ÖªµÀ¿ìµÄ×ßµœÁËÄ©Î²£¬È»ºóÂýµÄËùÔÚÎ»ÖÃŸÍÊÇÖÐŒäÎ»ÖÃ£¬ÕâÑùŸÍ·Ö³ÉÁËÁœ¶Î¡£mergeÊ±£¬°ÑÁœ¶ÎÍ·²¿œÚµãÖµ±ÈœÏ£¬ÓÃÒ»žö p ÖžÏòœÏÐ¡µÄ£¬ÇÒŒÇÂŒµÚÒ»žöœÚµã£¬È»ºó Áœ¶ÎµÄÍ·Ò»²œÒ»²œÏòºó×ß£¬pÒ²Ò»Ö±Ïòºó×ß£¬×ÜÊÇÖžÏòœÏÐ¡œÚµã£¬Ö±ÖÁÆäÖÐÒ»žöÍ·ÎªNULL£¬ŽŠÀíÊ£ÏÂµÄÔªËØ¡£×îºó·µ»ØŒÇÂŒµÄÍ·ŒŽ¿É¡£

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(head==NULL||head->next==NULL) return head;
        ListNode* p=head,*q=head,*pre;
        while(q&&q->next)
        {
            pre=p;
            p=p->next;
            q=q->next->next;
        }
        pre->next=NULL;
        return merge(sortList(head),sortList(p));
    }
    ListNode* merge(ListNode* ll,ListNode* lr)
    {
        ListNode* prehead=new ListNode(0),*p=prehead;
        while(ll&&lr)
        {
            if(ll->val<lr->val)
            {
                p->next=ll;
                ll=ll->next;
            }
            else
            {
                p->next=lr;
                lr=lr->next;
            }
            p=p->next;
        }
        if(ll!=NULL) p->next=ll;
        if(lr!=NULL) p->next=lr;
        return prehead->next;
    }
};



150. Evaluate Reverse Polish Notation
my method:stack
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> s;
        for(int i=0;i<tokens.size();i++)
        {
            if(tokens[i]=="+"||tokens[i]=="-"||tokens[i]=="*"||tokens[i]=="/")
            {
                int num1=s.top();
                s.pop();
                int num2=s.top();
                s.pop();
                if(tokens[i]=="+") s.push(num1+num2);
                if(tokens[i]=="-") s.push(num2-num1);
                if(tokens[i]=="*") s.push(num2*num1);
                if(tokens[i]=="/") s.push(num2/num1);
                
            }
            else
            s.push(stoi(tokens[i]));
        }
        return s.top();
    }
};





152. Maximum Product Subarray
method:DP
ÆäÊµ×ÓÊý×é³Ë»ý×îŽóÖµµÄ¿ÉÄÜÐÔÎª£ºÀÛ³ËµÄ×îŽóÖµÅöµœÁËÒ»žöÕýÊý£»»òÕß£¬ÀÛ³ËµÄ×îÐ¡Öµ£šžºÊý£©£¬ÅöµœÁËÒ»žöžºÊý¡£ËùÒÔÃ¿ŽÎÒª±£ŽæÀÛ³ËµÄ×îŽó£šÕýÊý£©ºÍ×îÐ¡Öµ£šžºÊý£©¡£Í¬Ê±»¹ÓÐÒ»žöÑ¡ÔñÆðµãµÄÂßŒ­£¬Èç¹ûÖ®Ç°µÄ×îŽóºÍ×îÐ¡ÖµÍ¬µ±Ç°ÔªËØÏà³ËÖ®ºó£¬Ã»ÓÐµ±Ç°ÔªËØŽó£š»òÐ¡£©ÄÇÃŽµ±Ç°ÔªËØŸÍ¿É×÷ÎªÐÂµÄÆðµã¡£ÀýÈç£¬Ç°Ò»žöÔªËØÎª0µÄÇé¿ö£¬{1,0,9,2}£¬µœ9µÄÊ±ºò9ÓŠžÃ×÷ÎªÒ»žö×îŽóÖµ£¬Ò²ŸÍÊÇÐÂµÄÆðµã£¬{1,0,-9,-2}Ò²ÊÇÍ¬ÑùµÀÀí£¬-9±Èµ±Ç°×îÐ¡Öµ»¹Ð¡£¬ËùÒÔžüÐÂÎªµ±Ç°×îÐ¡Öµ¡£

class Solution {
public:
    int maxProduct(vector<int>& nums) {
        if(nums.size()==0) return 0;
        int imax=nums[0],imin=nums[0],maxres=nums[0];
        for(int i=1;i<nums.size();i++)
        {
            if(nums[i]<0)
            swap(imax,imin);
            imax=max(nums[i],imax*nums[i]);
            imin=min(nums[i],imin*nums[i]);
            maxres=max(maxres,imax);
        }
        return maxres;
    }
};



153. Find Minimum in Rotated Sorted Array
my Method 1:
class Solution {
public:
    int findMin(vector<int>& nums) {
        for(int i=1;i<nums.size();i++)
        {
            if(nums[i]<nums[i-1])
            return nums[i];
        }
        return nums[0];
    }
};
method 2:binary search;Looking at subarray with index [start,end]. We can find out that if the first member is less than the last member, there's no rotation in the array. So we could directly return the first element in this subarray.

If the first element is larger than the last one, then we compute the element in the middle, and compare it with the first element. If value of the element in the middle is larger than the first element, we know the rotation is at the second half of this array. Else, it is in the first half in the array.

 int findMin(vector<int> &num) {
        int start=0,end=num.size()-1;
        
        while (start<end) {
            if (num[start]<num[end])
                return num[start];
            
            int mid = (start+end)/2;
            
            if (num[mid]>=num[start]) {
                start = mid+1;
            } else {
                end = mid;
            }
        }
        
        return num[start];
    }



154. Find Minimum in Rotated Sorted Array II
my method:
class Solution {
public:
    int findMin(vector<int>& nums) {
        for(int i=1;i<nums.size();i++)
        {
            if(nums[i]<nums[i-1])
            return nums[i];
        }
        return nums[0];
    }
};

method 2: binary search
class Solution {
public:
    int findMin(vector<int> &num) {
        int lo = 0;
        int hi = num.size() - 1;
        int mid = 0;
        
        while(lo < hi) {
            mid = lo + (hi - lo) / 2;
            
            if (num[mid] > num[hi]) {
                lo = mid + 1;
            }
            else if (num[mid] < num[hi]) {
                hi = mid;
            }
            else { // when num[mid] and num[hi] are same
                hi--;
            }
        }
        return num[lo];
    }
};



155. Min Stack
my method:hashtable;stack
class MinStack {
public:
    /** initialize your data structure here. */
    stack<int> st;
    map<int,int> hs;
    MinStack() {
        while(!st.empty()) st.pop();
        hs.clear();
    }
    
    void push(int x) {
        st.push(x);
        hs[x]++;
    }
    
    void pop() {
        hs[st.top()]--;
        if(hs[st.top()]==0) hs.erase(hs.find(st.top()));
        st.pop();
    }
    
    int top() {
        return st.top();
    }
    
    int getMin() {
        return hs.begin()->first;
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */

method 2:pair;one stack
class MinStack {
public:
    /** initialize your data structure here. */
    stack<pair<int,int>> st;
    int mini;
    MinStack() {
        while(!st.empty()) st.pop();
    }
    
    void push(int x) {
        mini=st.empty()?x:min(x,st.top().second);
        st.push({x,mini});//or make_pair(x,mini)
    }
    
    void pop() {
        st.pop();
    }
    
    int top() {
        return st.top().first;
    }
    
    int getMin() {
        return st.top().second;
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */




162. Find Peak Element
my method 1:
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        if(nums.size()==1||nums.size()==0) return 0;
        for(int i=0;i<nums.size();i++)
        {
            if(i==0) 
            {
                if(nums[i]>nums[i+1]) return i;
            }
            else if(i==nums.size()-1)
            {
                if(nums[i]>nums[i-1]) return i;
            }
            else 
            {
                if(nums[i]>nums[i-1]&&nums[i]>nums[i+1]) return i;
            }
        }
        return 0;
    
    }
};


method 2:binary search
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        if(nums.size()==1||nums.size()==0) return 0;
        int low=0,high=nums.size()-1;
        while(low<high)
        {
            int mid=low+(high-low)/2;
            if(nums[mid]<nums[mid+1]) low=mid+1;
            else high=mid;
        }
        
        return low;
    
    }
};




167. Two Sum II - Input array is sorted
my method 1:hash table
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        map<int,int> hs;
        vector<int> res;
        for(int i=0;i<numbers.size();i++)
        {
            if(hs.find(numbers[i])!=hs.end())
            {
                res.push_back(hs[numbers[i]]+1);
                res.push_back(i+1);
            }
            hs[target-numbers[i]]=i;
        }
        return res;
    }
};

method 2: two pointers,java
public int[] twoSum(int[] num, int target) {
    int[] indice = new int[2];
    if (num == null || num.length < 2) return indice;
    int left = 0, right = num.length - 1;
    while (left < right) {
        int v = num[left] + num[right];
        if (v == target) {
            indice[0] = left + 1;
            indice[1] = right + 1;
            break;
        } else if (v > target) {
            right --;
        } else {
            left ++;
        }
    }
    return indice;
}



168. Excel Sheet Column Title
my method:
class Solution {
public:
    string convertToTitle(int n) {
        string s;
        int k=1;
        while(n)
        {
            char c=(char)((n-1)%26+'A');
            string str(1,c);//
            s.insert(0,str);
            n=(n-1)/26;//52:AZ
        }
        return s;
    }
};


169. Majority Element
my method: hashtable
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        map<int,int> hs;
        int i;
        for(i=0;i<nums.size();i++)
        {
            hs[nums[i]]++;
            if(hs[nums[i]]>nums.size()/2)
            break;
        }
        return nums[i];
    }
};

method 2: o(1) space java
public class Solution {
    public int majorityElement(int[] num) {

        int major=num[0], count = 1;
        for(int i=1; i<num.length;i++){
            if(count==0){
                count++;
                major=num[i];
            }else if(major==num[i]){
                count++;
            }else count--;
            
        }
        return major;
    }
}



171. Excel Sheet Column Number
my method:
class Solution {
public:
    int titleToNumber(string s) {
        int sum=0,count=s.size()-1;
        for(int i=0;i<s.size();i++)
        {
            sum+=pow(26,count--)*(s[i]-'A'+1);//method 2:sum+=sum*26+s[i]-'A'+1;
        }
        return sum;
    }
};



172. Factorial Trailing Zeroes
method: math
Because all trailing 0 is from factors 5 * 2.

But sometimes one number may have several 5 factors, for example, 25 have two 5 factors, 125 have three 5 factors.
25:6 zeros
class Solution {
public:
    int trailingZeroes(int n) {
        int count=0;
        while(n)
        {
            count+=n/5;
            n=n/5;
        }
        return count;
    }
};




173.
method: stack
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class BSTIterator {
    stack<TreeNode *> st;
public:
    BSTIterator(TreeNode *root) {
        pushAll(root);
    }

    /** @return whether we have a next smallest number */
    bool hasNext() {
        return !st.empty();
    }

    /** @return the next smallest number */
    int next() {
        TreeNode* root=st.top();
        st.pop();
        pushAll(root->right);
        return root->val;
    }
private:
 void pushAll(TreeNode *root)
 {
     while(root)
     {
         st.push(root);
         root=root->left;
     }
 }

};

/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = BSTIterator(root);
 * while (i.hasNext()) cout << i.next();
 */



174. Dungeon Game
method:dp
class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        int M = dungeon.size();
        int N = dungeon[0].size();
        // hp[i][j] represents the min hp needed at position (i, j)
        // Add dummy row and column at bottom and right side
        vector<vector<int> > hp(M + 1, vector<int>(N + 1, INT_MAX));
        hp[M][N - 1] = 1;
        hp[M - 1][N] = 1;
        for (int i = M - 1; i >= 0; i--) {
            for (int j = N - 1; j >= 0; j--) {
                int need = min(hp[i + 1][j], hp[i][j + 1]) - dungeon[i][j];
                hp[i][j] = need <= 0 ? 1 : need;
            }
        }
        return hp[0][0];
    }
};



187. Repeated DNA Sequences
my method :hashtable
class Solution {
public:
    vector<string> findRepeatedDnaSequences(string s) {
        if(s.size()<10) return {};
        map<string,int> hs;
        vector<string> res;
        for(int i=0;i<s.size()-9;i++)
        {
            string str=s.substr(i,10);
            if(hs[str]==1)
              res.push_back(str);
            hs[str]++;
        }
        return res;
    }
};

method 2:bitmanipulation and hashtable
The main idea is to store the substring as int in map to bypass the memory limits.

There are only four possible character A, C, G, and T, but I want to use 3 bits per letter instead of 2.

Why? It's easier to code.

A is 0x41, C is 0x43, G is 0x47, T is 0x54. Still don't see it? Let me write it in octal.

A is 0101, C is 0103, G is 0107, T is 0124. The last digit in octal are different for all four letters. That's all we need!

We can simply use s[i] & 7 to get the last digit which are just the last 3 bits, it's much easier than lookup table or switch or a bunch of if and else, right?

We don't really need to generate the substring from the int. While counting the number of occurrences, we can push the substring into result as soon as the count becomes 2, so there won't be any duplicates in the result.

vector<string> findRepeatedDnaSequences(string s) {
    unordered_map<int, int> m;
    vector<string> r;
    int t = 0, i = 0, ss = s.size();
    while (i < 9)
        t = t << 3 | s[i++] & 7;
    while (i < ss)
        if (m[t = t << 3 & 0x3FFFFFFF | s[i++] & 7]++ == 1)
            r.push_back(s.substr(i - 10, 10));
    return r;
}


188. Best Time to Buy and Sell Stock IV
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        // f[k, i] represents the max profit up until prices[ii] (Note: NOT ending with prices[i]) using at most k transactions. 
        // f[k, i] = max(f[k, i-1], prices[i] - prices[j] + f[k-1, j]) {j in range of [0, ii-1] }
        //          = max(f[k, i-1], prices[i] + max(f[k-1, j] - prices[j]))
        // f[0, i] = 0; 0 times transation makes 0 profit
        // f[k, 0] = 0; if there is only one price data point you can't make any money no matter how many times 
        int len=prices.size();
        if(len<=1) return 0;
        
        int sum=0;
        if(k>=len/2)//just like this problem II
        {
            for(int i=0;i<len-1;i++)
            {
                if(prices[i+1]>prices[i])
                sum+=prices[i+1]-prices[i];
            }
            return sum;
        }
        
        vector<vector<int>> res(k+1,vector<int>(len,0));
        for(int i=1;i<=k;i++)
        {
            int tmpmax=-prices[0];
            for(int j=1;j<len;j++)
            {
                res[i][j]=max(res[i][j-1],tmpmax+prices[j]);
                tmpmax=max(tmpmax,res[i-1][j]-prices[j]);
            }
            
        }
        return res[k][len-1];
    }
};



191. Number of 1 Bits
my method:bit manipulation
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int sum=0;
        for(int i=0;i<32;i++)
        {
            if((n>>i)&1)
            sum+=1;
        }
        return sum;
    }
};



198. House Robber
my method:DP
class Solution {
public:
    int rob(vector<int>& nums) {
        int size=nums.size();
        if(size==0) return 0;
        if(size==1) return nums[0];
        vector<vector<int>> res(2,vector<int>(size,0));
        res[1][0]=nums[0];
        for(int i=1;i<size;i++)
        {
            res[0][i]=max(res[1][i-1],res[0][i-1]);//Õâžö²»ÇÀ  Ç°ÃæÄÇžö¿ÉÇÀÒ²¿É²»ÇÀ
            res[1][i]=res[0][i-1]+nums[i];
        }
        return max(res[0][size-1],res[1][size-1]);
        
    }
};
žÄœø£ºËõÐ¡¿ÕŒä
class Solution {
public:
    int rob(vector<int>& nums) {
        int size=nums.size();
        if(size==0) return 0;
        if(size==1) return nums[0];
        int res0=0,res1=nums[0];
        for(int i=1;i<size;i++)
        {
            int pre=res0;
            res0=max(res1,res0);//Õâžö²»ÇÀ  Ç°ÃæÄÇžö¿ÉÇÀÒ²¿É²»ÇÀ
            res1=pre+nums[i];
        }
        return max(res0,res1);
        
    }
};



199. Binary Tree Right Side View
my method :²ãŽÎ±éÀú
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        if(!root) return {};
        queue<TreeNode*> q;
        q.push(root);
        vector<int> res;
        int levelnum=1;
        while(!q.empty())
        {
            int levelcount=0;
            for(int i=0;i<levelnum;i++)
            {
                root=q.front();
                q.pop();
                if(root->left) 
                {
                    q.push(root->left);
                    levelcount++;
                }
                if(root->right) 
                {
                    q.push(root->right);
                    levelcount++;
                }
                if(i==levelnum-1)
                res.push_back(root->val);
            }
            levelnum=levelcount;
        }
        return res;
    }
};

method 2:
The core idea of this algorithm:

1.Each depth of the tree only select one node.

View depth is current size of result list.

public class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<Integer>();
        rightView(root, result, 0);
        return result;
    }
    
    public void rightView(TreeNode curr, List<Integer> result, int currDepth){
        if(curr == null){
            return;
        }
        if(currDepth == result.size()){
            result.add(curr.val);
        }
        
        rightView(curr.right, result, currDepth + 1);
        rightView(curr.left, result, currDepth + 1);
        
    }
}



200. Number of Islands
method:dfs
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        if(grid.size()==0) return 0;
        int count=0;
        for(int i=0;i<grid.size();i++)
        {
            for(int j=0;j<grid[i].size();j++)
            {
                if(grid[i][j]=='1')
                {
                    dfsmark(grid,i,j);
                    count++;
                }
            }
        }
        return count;
    }
    
    void dfsmark(vector<vector<char>>& grid,int i,int j)
    {
        if(i<0||i==grid.size()||j<0||j==grid[0].size()||grid[i][j]=='0') return;
        grid[i][j]='0';
        dfsmark(grid,i,j+1);
        dfsmark(grid,i+1,j);
        dfsmark(grid,i-1,j);
        dfsmark(grid,i,j-1);
    }
};



204. Count Primes
method:The Sieve of Eratosthenes(°£ÊÏÉž·š) uses an extra O(n) memory and its runtime complexity is O(n log log n).
class Solution {
public:
    int countPrimes(int n) {
        
        vector<bool> isPrime(n,true);
        isPrime[0]=false;
        isPrime[1]=false;
   // Loop's ending condition is i * i < n instead of i < sqrt(n)
   // to avoid repeatedly calling an expensive function sqrt().
      for (int i = 2; i * i < n; i++) 
      {
      if (!isPrime[i]) continue;
      for (int j = i * i; j < n; j += i) 
      {
         isPrime[j] = false;
      }
      }
   int count = 0;
   for (int i = 2; i < n; i++) {
      if (isPrime[i]) count++;
   }
   return count;
    }
   
};



205. Isomorphic Strings
my mwthod :hashtable
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        map<char,int> hs1,hs2;
        for(int i=0;i<s.size();i++)
        {
            //position 0 and initiation 0 should be distinguish£» test case:aa ab   also can make  hs1[s[i]]=i+1; hs2[t[i]]=i+1;
            if(((hs1.find(s[i])==hs1.end())^(hs2.find(t[i])==hs2.end())==1)||(hs1[s[i]]!= hs2[t[i]]))
            return false;
            hs1[s[i]]=i;
            hs2[t[i]]=i;
            
        }
        return true;
    }
};


207. Course Schedule
method 1:bfs
BFS uses the indegrees of each node. We will first try to find a node with 0 indegree. If we fail to do so, there must be a cycle in the graph and we return false. Otherwise we have found one. We set its indegree to be -1 to prevent from visiting it again and reduce the indegrees of all its neighbors by 1. This process will be repeated for n (number of nodes) times. If we have not returned false, we will return true.

class Solution {
public:
    bool canFinish(int numCourses, vector<pair<int, int>>& prerequisites) {
        vector<unordered_set<int>> graph = make_graph(numCourses, prerequisites);
        vector<int> degrees = compute_indegree(graph);
        for (int i = 0; i < numCourses; i++) {
            int j = 0;
            for (; j < numCourses; j++)
                if (!degrees[j]) break;
            if (j == numCourses) return false;
            degrees[j] = -1;
            for (int neigh : graph[j])
                degrees[neigh]--;
        }
        return true;
    }
private:
    vector<unordered_set<int>> make_graph(int numCourses, vector<pair<int, int>>& prerequisites) {
        vector<unordered_set<int>> graph(numCourses);
        for (auto pre : prerequisites)
            graph[pre.second].insert(pre.first);
        return graph;
    }
    vector<int> compute_indegree(vector<unordered_set<int>>& graph) {
        vector<int> degrees(graph.size(), 0);
        for (auto neighbors : graph)
            for (int neigh : neighbors)
                degrees[neigh]++;
        return degrees;
    }
}; 

method 2:dfs(don't understand)
For DFS, it will first visit a node, then one neighbor of it, then one neighbor of this neighbor... and so on. If it meets a node which was visited in the current process of DFS visit, a cycle is detected and we will return false. Otherwise it will start from another unvisited node and repeat this process till all the nodes have been visited. Note that you should make two records: one is to record all the visited nodes and the other is to record the visited nodes in the current DFS visit.

The code is as follows. We use a vector<bool> visited to record all the visited nodes and another vector<bool> onpath to record the visited nodes of the current DFS visit. Once the current visit is finished, we reset the onpath value of the starting node to false.

class Solution {
public:
    bool canFinish(int numCourses, vector<pair<int, int>>& prerequisites) {
        vector<unordered_set<int>> graph = make_graph(numCourses, prerequisites);
        vector<bool> onpath(numCourses, false), visited(numCourses, false);
        for (int i = 0; i < numCourses; i++)
            if (!visited[i] && dfs_cycle(graph, i, onpath, visited))
                return false;
        return true;
    }
private:
    vector<unordered_set<int>> make_graph(int numCourses, vector<pair<int, int>>& prerequisites) {
        vector<unordered_set<int>> graph(numCourses);
        for (auto pre : prerequisites)
            graph[pre.second].insert(pre.first);
        return graph;
    } 
    bool dfs_cycle(vector<unordered_set<int>>& graph, int node, vector<bool>& onpath, vector<bool>& visited) {
        if (visited[node]) return false;
        onpath[node] = visited[node] = true; 
        for (int neigh : graph[node])
            if (onpath[neigh] || dfs_cycle(graph, neigh, onpath, visited))
                return true;
        return onpath[node] = false;//?
    }
};




208. Implement Trie (Prefix Tree)
method:
class TrieNode {
public:
    TrieNode* children[26];
    bool isWord;

    // Initialize your data structure here.
    TrieNode() {
        memset(children,0,sizeof(children));
        isWord=false;
    }
};

class Trie {
public:
    Trie() {
        root = new TrieNode();
    }

    // Inserts a word into the trie.
    void insert(string word) {
        TrieNode* p=root;
        for(int i=0;i<word.size();i++)
        {
            if(p->children[word[i]-'a']==NULL)
            {
                p->children[word[i]-'a']=new TrieNode();
            }
            p=p->children[word[i]-'a'];
        }
        p->isWord=true;
    }

    // Returns if the word is in the trie.
    bool search(string word) {
        TrieNode* p=root;
        for(int i=0;i<word.size();i++)
        {
            if(p->children[word[i]-'a']==NULL)
            {
                return false;
            }
            p=p->children[word[i]-'a'];
        }
        return p->isWord;
    }

    // Returns if there is any word in the trie
    // that starts with the given prefix.
    bool startsWith(string prefix) {
        TrieNode* p=root;
        for(int i=0;i<prefix.size();i++)
        {
            if(p->children[prefix[i]-'a']==NULL)
            {
                return false;
            }
            p=p->children[prefix[i]-'a'];
        }
        return p!=NULL;
    }

private:
    TrieNode* root;
};

// Your Trie object will be instantiated and called as such:
// Trie trie;
// trie.insert("somestring");
// trie.search("key");




209. Minimum Size Subarray Sum
my method:two pointers
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        //sort(nums.begin(),nums.end());
        int count=INT_MAX,sum=0,j=0;
        for(int i=0;i<nums.size();i++)
        {
            if(count==1) break;
            sum+=nums[i];
            if(sum>=s) 
            {
                while(sum-nums[j]>=s) 
                {
                    sum-=nums[j];
                    j++;
                }
                count=min(count,i-j+1);
            }
            
            
        }
        return count==INT_MAX?0:count;
    }
};



211. Add and Search Word - Data structure design
method:backtrack and trie
class TrieNode{
public:
    TrieNode* children[26];
    bool isWord;
    TrieNode()
    {
        isWord=false;
        memset(children,NULL,sizeof(TrieNode*)*26);
    }
};
class WordDictionary {
private:
TrieNode* root= new TrieNode();
bool query(string word,TrieNode* node)
{
    TrieNode* cur=node;
    for(int i=0;i<word.size();i++)
    {
        char c=word[i];
        if(cur&&c!='.') 
        {
            cur=cur->children[c-'a'];
        }
        else if(cur&&c=='.')
        {
            TrieNode* tmp = cur;
            for (int j = 0; j < 26; j++)
            {
                cur = tmp -> children[j];
                if (query(word.substr(i+1), cur))//why not cur->children[j]?
                    return true;
            }
        }
        else break;
        
    }
    return cur&&cur->isWord;
}
public:

    // Adds a word into the data structure.
    void addWord(string word) {
        TrieNode* p=root;
        for(char c:word)
        {
            if(p->children[c-'a']==NULL)
            {
                p->children[c-'a']=new TrieNode();
            }
               
            p=p->children[c-'a'];
        }
        p->isWord=true;
    }

    // Returns if the word is in the data structure. A word could
    // contain the dot character '.' to represent any one letter.
    bool search(string word) {
        return query(word,root);
    }
    
};

// Your WordDictionary object will be instantiated and called as such:
// WordDictionary wordDictionary;
// wordDictionary.addWord("word");
// wordDictionary.search("pattern");





213. House Robber II
my method:
class Solution {
public:
    int rob(vector<int>& nums) {
        int size=nums.size();
        if(size==0) return 0;
        if(size==1) return nums[0];
        int res0=0,res1=nums[1],res2=nums[0],res3=nums[0];//res0,res1ÎªµÚÒ»žö²»ÇÀ£¬res3£¬res4ÁœžöÊÇµÚÒ»žöÇÀ
        for(int i=2;i<size;i++)
        {
            int pre=res0;
            res0=max(res1,res0);//Õâžö²»ÇÀ  Ç°ÃæÄÇžö¿ÉÇÀÒ²¿É²»ÇÀ
            res1=pre+nums[i];
            if(i!=size-1)
            {
                int pre=res2;
                res2=max(res3,res2);
                res3=pre+nums[i];
            }
        }
        
        return max(max(res0,res1),max(res2,res3));
    }
};

method 2£ºÓÃHouse Robber IµÄœá¹û java
private int rob(int[] num, int lo, int hi) {
    int include = 0, exclude = 0;
    for (int j = lo; j <= hi; j++) {
        int i = include, e = exclude;
        include = e + num[j];
        exclude = Math.max(e, i);
    }
    return Math.max(include, exclude);
}
public int rob(int[] nums) {
    if (nums.length == 1) return nums[0];
    return Math.max(rob(nums, 0, nums.length - 2), rob(nums, 1, nums.length - 1));
}


 

214. Shortest Palindrome 
method 1:
The idea is to use two anchors j and i to compare the String from beginning and end.
If j can reach the end, the String itself is Palindrome. Otherwise, we divide the String by j, and get mid = s.substring(0, j) and suffix.

We reverse suffix as beginning of result and recursively call shortestPalindrome to get result of mid then appedn suffix to get result.

class Solution {
public:
    string shortestPalindrome(string s) {
    int j = 0;
    for(int i=s.size()-1; i>=0; i--)
        if(s[j]==s[i])  j++;
    if(j==s.size())  return s;
    string suffix = s.substr(j); 
    return string(suffix.rbegin(), suffix.rend()) + shortestPalindrome(s.substr(0,j)) + suffix;//0~j²»Ò»¶šÊÇPALINDROME
}

};

method 2:KMP(don't understand)
class Solution {
public:
    string shortestPalindrome(string s) {
        string rev_s = s;
        reverse(rev_s.begin(), rev_s.end());
        string l = s + "#" + rev_s;
        
        vector<int> p(l.size(), 0);
        for (int i = 1; i < l.size(); i++) {
            int j = p[i - 1];
            while (j > 0 && l[i] != l[j])
                j = p[j - 1];
            p[i] = (j += l[i] == l[j]);
        }
        
        return rev_s.substr(0, s.size() - p[l.size() - 1]) + s;
    }
};




215. Kth Largest Element in an Array
my method:sort;19ms
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end());
        return nums[nums.size()-k];
    }
};

method 2:quick sort;192ms
1.Initialize left to be 0 and right to be nums.size() - 1;
2.Partition the array, if the pivot is at the k-1-th position, return it (we are done);
3.If the pivot is right to the k-1-th position, update right to be the left neighbor of the pivot;
4.Else update left to be the right neighbor of the pivot.
5.Repeat 2.

class Solution {
public:
    int partition(vector<int>& nums, int left, int right) {
        int pivot = nums[left];
        int l = left + 1, r = right;
        while (l <= r) {
            if (nums[l] < pivot && nums[r] > pivot)
                swap(nums[l++], nums[r--]);
            if (nums[l] >= pivot) l++; 
            if (nums[r] <= pivot) r--;
        }
        swap(nums[left], nums[r]);
        return r;
    }
    
    int findKthLargest(vector<int>& nums, int k) {
        int left = 0, right = nums.size() - 1;
        while (true) {
            int pos = partition(nums, left, right);
            if (pos == k - 1) return nums[pos];
            if (pos > k - 1) right = pos - 1;
            else left = pos + 1;
        }
    }
};

method 3:19ms
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
         priority_queue<int> pq(nums.begin(), nums.end());
        for (int i = 0; i < k - 1; i++)
            pq.pop(); 
        return pq.top();
        
    }
};



221. Maximal Square
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        int n=matrix.size();
        if(n==0) return 0;
        int m=matrix[0].size();
        vector<vector<int>> dp(n,vector<int>(m));
        int maxarea=0;
        for(int i=0;i<n;i++)
        {
            dp[i][0]=matrix[i][0]-'0';
            maxarea=max(maxarea,dp[i][0]);
        }
        for(int j=0;j<m;j++)
        {
            dp[0][j]=matrix[0][j]-'0';
            maxarea=max(maxarea,dp[0][j]);
        }
        
        for(int i=1;i<n;i++)
        {
            for(int j=1;j<m;j++)
            {
                if(matrix[i][j]=='1')
                {
                    dp[i][j]=min(min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1])+1;
                    //cout<<dp[i][j];
                }
                else
                dp[i][j]=0;
                maxarea=max(maxarea,dp[i][j]);
            }
        }
       // cout<<dp[1][2];
        return maxarea*maxarea;
    }
};

use less space:
int maximalSquare(vector<vector<char>>& matrix) {
	int m = matrix.size();
	if (!m) return 0;
	int n = matrix[0].size();
	vector<int> pre(m, 0);
	vector<int> cur(m, 0);
	int maxsize = 0;
	for (int i = 0; i < m; i++) {
		pre[i] = matrix[i][0] - '0';
		maxsize = max(maxsize, pre[i]);
	}
	for (int j = 1; j < n; j++) {
		cur[0] = matrix[0][j] - '0';
		maxsize = max(maxsize, cur[0]);
		for (int i = 1; i < m; i++) {
			if (matrix[i][j] == '1') {
				cur[i] = min(cur[i - 1], min(pre[i - 1], pre[i])) + 1;
				maxsize = max(maxsize, cur[i]);
			}
		}
		swap(pre, cur);
		fill(cur.begin(), cur.end(), 0);
	}
	return maxsize * maxsize;
}

optimize:
int maximalSquare(vector<vector<char>>& matrix) {
    if (matrix.empty()) return 0;
    int m = matrix.size(), n = matrix[0].size();
    vector<int> dp(m + 1, 0);
    int maxsize = 0, pre = 0;
    for (int j = 0; j < n; j++) {
        for (int i = 1; i <= m; i++) {
            int temp = dp[i];
            if (matrix[i - 1][j] == '1') {
                dp[i] = min(dp[i], min(dp[i - 1], pre)) + 1;
                maxsize = max(maxsize, dp[i]);
            }
            else dp[i] = 0; 
            pre = temp;
        }
    }
    return maxsize * maxsize;
}





222.
method 1: It first walks all the way left and right to determine the height and whether it's a full tree, meaning the last row is full. else it's timelimited
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root==NULL) return 0;
        int lheight=1,rheight=1;
        TreeNode* l=root,*r=root;
        while(l->left) 
        {
            l=l->left;
            lheight++;
        }
        while(r->right) 
        {
            r=r->right;
            rheight++;
        }
        if(lheight==rheight) return  (1 << lheight) - 1;
        return 1+countNodes(root->left)+countNodes(root->right);
    }
};



223. Rectangle Area
my method:math
class Solution {
public:
    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {
        int area=abs((C-A)*(D-B))+abs((G-E)*(H-F));
        cout<<area;
        if(E<C&&H>B)//Ö»ÐèÒª¿ŒÂÇÇ°Ò»žö³€·œÐÎÔÚºóÃæÄÇžö×ó±ß
        {
            int a=(min(C,G)-max(E,A)),b=(min(D,H)-max(B,F));
            if(a>0&&b>0) area-=a*b;
        }
        return area;
    }
};

method 2: ²»ÓÃÈ·ÈÏÊÇ·ñž²žÇ
class Solution {
public:
    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {
        int left = max(A,E), right = max(min(C,G), left);
        int bottom = max(B,F), top = max(min(D,H), bottom);
        return (C-A)*(D-B) - (right-left)*(top-bottom) + (G-E)*(H-F);
    }
};




225. Implement Stack using Queues
my method:
class Stack {
public:
queue<int> inq,outq;
    // Push element x onto stack.
    void push(int x) {
        inq.push(x);
    }

    // Removes the element on top of the stack.
    void pop() {
        while(outq.size()!=0) outq.pop();
        while(inq.size()!=1)//inqÍ¬Ê±ÔÚpop
        {
            outq.push(inq.front());
            inq.pop();
        }
        inq.pop();
        inq=outq;
    }

    // Get the top element.
    int top() {
        return inq.back();
    }

    // Return whether the stack is empty.
    bool empty() {
        return inq.size()==0;
    }
};



229. Majority Element II
method :
class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        //ÄŠ¶ûÍ¶Æ±·š Boyer-Moore Majority Vote algorithm,
        int count1=0,count2=0,candidate1=0,candidate2=1;//È·±£ÁœžöºòÑ¡²»ÏëµÈ
        for(int num:nums)
        {
            if(num==candidate1) count1++;
            else if(num==candidate2) count2++;
            else if(count1==0) candidate1=num,count1++;
            else if(count2==0) candidate2=num,count2++;
            else count1--,count2--;
        }
        count1=0,count2=0;
        for(int num:nums)
        {
            if(num==candidate1) count1++;
            if(num==candidate2) count2++;
        }
        vector<int> res;
        if(count1>nums.size()/3) res.push_back(candidate1);
        if(count2>nums.size()/3) res.push_back(candidate2);
        return res;
    }
};



231. Power of Two
my method:math
class Solution {
public:
    bool isPowerOfTwo(int n) {
        int i=1;
        while(n)
        {
            if(n==1)
            return true;
            if(n%2==1&&n!=1)
            return false;
            else
            n=n/2;
        }
        return false;
    }
};

method 2:bit manipunation
Power of 2 (2µÄŽÎ·œÊý)means only one bit of n is '1'
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if(n<=0) return false;
        return !(n&(n-1));
    }
};



232. Implement Queue using Stacks
I have one input stack, onto which I push the incoming elements, and one output stack, from which I peek/pop. I move elements from input stack to output stack when needed, i.e., when I need to peek/pop but the output stack is empty. When that happens, I move all elements from input to output stack, thereby reversing the order so it's the correct order for peek/pop.
class Queue {
public:
    stack<int> input,output;
    // Push element x to the back of queue.
    void push(int x) {
        input.push(x);
    }

    // Removes the element from in front of queue.
    void pop(void) {
        peek();
        output.pop();
    }

    // Get the front element.
    int peek(void) {
        if(output.empty())
        {
            while(!input.empty())
            {
            output.push(input.top());
            input.pop();
            }
        }
        return output.top();
    }

    // Return whether the queue is empty.
    bool empty(void) {
        return input.empty()&&output.empty();
    }
};



233. Number of Digit One
method:math
/Ã¿10žöÊý, ÓÐÒ»žöžöÎ»ÊÇ1,
     //Ã¿100žöÊý, ÓÐ10žöÊ®Î»ÊÇ1, 
     //Ã¿1000žöÊý, ÓÐ100žö°ÙÎ»ÊÇ1. 
     //×öÒ»žöÑ­»·, Ã¿ŽÎŒÆËã µ¥žöÎ»ÉÏ1 µÄ×ÜžöÊý£šžöÎ»,Ê®Î», °ÙÎ»£©
     
     //ÒÔËã°ÙÎ»ÉÏ1ÎªÀý×Ó:   ŒÙÉè°ÙÎ»ÉÏÊÇ0, 1, ºÍ >=2 ÈýÖÖÇé¿ö: 
    //case 1: n=3141092, a= 31410, b=92. ŒÆËã°ÙÎ»ÉÏ1µÄžöÊýÓŠžÃÎª 3141 *100 ŽÎ.
    //case 2: n=3141192, a= 31411, b=92. ŒÆËã°ÙÎ»ÉÏ1µÄžöÊýÓŠžÃÎª 3141 *100 + (92+1) ŽÎ. 
    //case 3: n=3141592, a= 31415, b=92. ŒÆËã°ÙÎ»ÉÏ1µÄžöÊýÓŠžÃÎª (3141+1) *100 ŽÎ. 
    
    //ÒÔÉÏÈýÖÖÇé¿ö¿ÉÒÔÓÃ Ò»žö¹«ÊœžÅÀš:m±íÊŸÎ»Êý
    //(a + 8) / 10 * m + (a % 10 == 1) * (b + 1);

class Solution {
public:
    int countDigitOne(int n) {
        int ones = 0;
        for (long long m = 1; m <= n; m *= 10) 
        {
        int a = n/m, b = n%m;
        ones += (a + 8) / 10 * m + (a % 10 == 1) * (b + 1);
        }
        return ones;
    }
};




235. Lowest Common Ancestor of a Binary Search Tree
my method: recursive
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(q->val<p->val)
        {
            swap(p,q);
        }
        if((p->val<=root->val&&q->val>root->val)||(p->val<root->val&&q->val>=root->val))
        return root;
        TreeNode* res;
        if(p->val<root->val)
        res= lowestCommonAncestor(root->left,p,q);
        if(q->val>root->val)
        res=lowestCommonAncestor(root->right,p,q);
        return res;
    }
};

method 2: java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    while ((root.val - p.val) * (root.val - q.val) > 0)
        root = p.val < root.val ? root.left : root.right;
    return root;
}


236. Lowest Common Ancestor of a Binary Tree
method: It's recursive and expands the meaning of the function. If the current (sub)tree contains both p and q, then the function result is their LCA. If only one of them is in that subtree, then the result is that one of them. If neither are in that subtree, the result is null/None/nil.
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (root==NULL || root == p || root == q) return root;
    TreeNode* left = lowestCommonAncestor(root->left, p, q);
    TreeNode* right = lowestCommonAncestor(root->right, p, q);
    return !left ? right : !right ? left : root;//p,q are not in lefttree then right tree elseif are not in right tree return root 
}
};


238. Product of Array Except Self
method :O(n) time o(1) space (first right order the reverse order)
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int> res(nums.size(),1);
        res[0]=1;
        for(int i=1;i<nums.size();i++)
        {
            res[i]=res[i-1]*nums[i-1];
        }
        int right=1;
        for(int i=nums.size()-1;i>=0;i--)
        {
            res[i]*=right;
            right*=nums[i];
        }
        return res;
    }
};


239. Sliding Window Maximum
method:deque
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> q;// q contains index
        vector<int> winmax;
        for(int i=0;i<nums.size();i++)
        {
            // remove numbers out of range k
            while(!q.empty()&&q.front()<i-k+1)
            q.pop_front();
            // remove smaller numbers befor i in k range as they are useless
            while(!q.empty()&&nums[q.back()]<nums[i])
            q.pop_back();
            
            q.push_back(i);
            if(i>=k-1) winmax.push_back(nums[q.front()]);
        }
        return winmax;
    }
};



240. Search a 2D Matrix II
method:
We start search the matrix from top right corner, initialize the current position to top right corner, if the target is greater than the value in current position, then the target can not be in entire row of current position because the row is sorted, if the target is less than the value in current position, then the target can not in the entire column because the column is sorted too. We can rule out one row or one column each time, so the time complexity is O(m+n).

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m=matrix.size();
        if(m==0) return false;
        int i=0,n=matrix[0].size(),j=n-1;
        while(i<m&&j>=0)
        {
            if(matrix[i][j]>target) j--;
            else if(matrix[i][j]<target) i++;
            else return true;
        }
        return false;
        
    }
};



241. Different Ways to Add Parentheses
method:divide and conquer
class Solution {
public:
    vector<int> diffWaysToCompute(string input) {
        vector<int> res;
        for(int i=0;i<input.size();i++)
        {
            if(input[i]=='+'||input[i]=='-'||input[i]=='*')
            {
                vector<int> part1=diffWaysToCompute(input.substr(0,i));
                vector<int> part2=diffWaysToCompute(input.substr(i+1));
                for(int p1:part1)
                for(int p2:part2)
                {
                    res.push_back(input[i]=='+'?p1+p2:input[i]=='-'?p1-p2:p1*p2);
                }
            }
        }
        if(res.size()==0) res.push_back(atoi(input.c_str()));
        return res;
    }
};




242. Valid Anagram
my method: hashtable
class Solution {
public:
    bool isAnagram(string s, string t) {
        map<char,int> hs1,hs2;
        for(int i=0;i<s.size();i++)
            hs1[s[i]]++;
        for(int i=0;i<t.size();i++)
            hs2[t[i]]++;
        return hs1==hs2;
    }
};



257.
my method: Binary Tree Paths
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> res;
        string s;
        preOrder(root,res,s);
        return res;
    }
    void preOrder(TreeNode* root,vector<string> &ress,string s)//s is not &s 
    {
        if(root==NULL) return ;
        stringstream ss;//also can use to_string(root->val)
        ss<<root->val;
        if(s.size()==0)
        ss>>s;
        else
        {
        string tmp;
        ss>>tmp;
        s=s+"->"+tmp;
        }
        if(root->left==NULL&&root->right==NULL)
        {
        ress.push_back(s);
        return ;
        }
        preOrder(root->left,ress,s);
        preOrder(root->right,ress,s);
    }
};

260. Single Number III
method : o(n) time o(1) space;if use hashtable o(n) space
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        //Ê×ÏÈŒÆËãnumsÊý×éÖÐËùÓÐÊý×ÖµÄÒì»ò£¬ŒÇÎªxor;Áîlowbit = xor & -xor£¬lowbitµÄº¬ÒåÎªxorŽÓµÍÎ»ÏòžßÎ»£¬µÚÒ»žö·Ç0Î»Ëù¶ÔÓŠµÄÊý×Ö
        //ÀýÈçŒÙÉèxor = 6£š¶þœøÖÆ£º0110£©£¬Ôò-xorÎª£š¶þœøÖÆ£º1010£¬-6µÄ²¹Âë£¬two's complement£©Ôòlowbit = 2£š¶þœøÖÆ£º0010£©
        int diff=0;
        for(int num:nums)
           diff^=num;
        diff&=-diff;
        
        vector<int> rets = {0, 0}; // this vector stores the two numbers we will return
        for (int num : nums)
        {
            if ((num & diff) == 0) // the bit is not set  Òì»òœá¹ûÎª1µÄ×îµÍÎ»ÉÏ£¬ÓÐÒ»žöÊý¿Ï¶šÎª0£¬ÄÇÃŽÕâžöÊýÓëdiffÏàÓëÎª0£»
            {
                rets[0] ^= num;
            }
            else // the bit is set
            {
                rets[1] ^= num;
            }
        }
        return rets;
    }
};



263. Ugly Number
my method:math
class Solution {
public:
    bool isUgly(int num) {
        while(num)
        {
            if(num==1) return true;
            if(num%2==0) num=num/2;
            else if(num%3==0) num=num/3;
            else if(num%5==0) num=num/5;
            else return false;
        }
        return false;
    }
};



264. Ugly Number II
method :DP
We have an array k of first n ugly number. We only know, at the beginning, the first one, which is 1. Then

k[1] = min( k[0]x2, k[0]x3, k[0]x5). The answer is k[0]x2. So we move 2's pointer to 1. Then we test:

k[2] = min( k[1]x2, k[0]x3, k[0]x5). 
class Solution {
public:
    int nthUglyNumber(int n) {
        if(n<=0) return false;
        vector<int> res(n,1);
        int i=0,j=0,k=0;
        for(int x=1;x<n;x++)
        {
           res[x]=min(res[i]*2,min(res[j]*3,res[k]*5));
           if(res[x]==res[i]*2) i++;
           if(res[x]==res[j]*3) j++;
           if(res[x]==res[k]*5) k++;
        }
        return res[n-1];
        
    }
};



268. Missing Number
my method :bit manipulation;let every num duplicate twice,^can lead to 0
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int res=nums.size();
        for(int i=0;i<nums.size();i++)
        {
            res=res^i^nums[i];
        }
        return res;
        
    }
};


274. H-Index
my method 1:sort first
class Solution {
public:
    int hIndex(vector<int>& citations) {
        sort(citations.begin(),citations.end());
        int i,n=citations.size(),res=0;
        for(i=n-1;i>=0;i--)
        {
            if(citations[i]>=n-i)
            {
                res=n-i;
            }
        }
        return res;
    }
};

method 2:hashtable
public class Solution {
    // 9.3 70 years diaoZhaTian China jiaYou 
    public int hIndex(int[] citations) {
        int length = citations.length;
        if (length == 0) {
        	return 0;
        }
        
        int[] array2 = new int[length + 1];
        for (int i = 0; i < length; i++) {
        	if (citations[i] > length) {
        		array2[length] += 1;
        	} else {
        		array2[citations[i]] += 1;
        	}
        }
        int t = 0;
        int result = 0;

        for (int i = length; i >= 0; i--) {
        	t = t + array2[i];
        	if (t >= i) {
        		return i;
        	}
        }
        return 0;
    }
}



275. H-Index II
my method :binary search
class Solution {
public:
    int hIndex(vector<int>& citations) {
        int n=citations.size();
        int low=0,high=n-1;
        while(low<=high)
        {
            int mid=low+(high-low)/2;
            //cout<<mid;
            if(citations[mid]>n-mid) 
            {
                if(citations[mid-1]<n-mid+1) return n-mid;
                high=mid;
            }
            else if(citations[mid]<n-mid) low=mid+1;
            else return n-mid;
        }
        
        return 0;
    }
};



279. Perfect Squares
my method:DP
705 ms
class Solution {
public:
    int numSquares(int n) {
        vector<int> squ;
        for(int i=1;i<=n;i++)
        {
            if(i*i>n) break;
            squ.push_back(i*i);
        }
        vector<int> res(n+1,1);
        res[0]=0;
        for(int i=1;i<=n;i++)
        {
            int mincount=INT_MAX;
            for(int j=0;j<squ.size();j++)
            {
                if(squ[j]>i) break;
                mincount=min(mincount,res[squ[j]]+res[i-squ[j]]);
            }
            res[i]=mincount;
        }
        return res[n];
    }
};

some optition:460ms
class Solution {
public:
    int numSquares(int n) {
        vector<int> res(n+1,INT_MAX);
        res[0]=0;
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j*j<=i;j++)
            {
                res[i]=min(res[i],res[i-j*j]+1);
            }
        }
        return res[n];
    }
};

further optition:static DP
The table can be reused. if you first call numSquares(100), a table with size 101 will be built. Then if you call numSquares(10), the function doesn't need to rebuild the table and it will immediately return the entry with index 10.

class Solution {
public:
    int numSquares(int n) {
        static vector<int> res({0});
        while(res.size()<=n)
        {
            int minres=INT_MAX,m=res.size();
            for(int j=1;j*j<=m;j++)
            {
                minres=min(minres,res[m-j*j]+1);
            }
            res.push_back(minres);
        }
        return res[n];
    }
};


method 2:Breadth-First Search ;80 ms;don't understand
class Solution 
{
public:
    int numSquares(int n) 
    {
        if (n <= 0)
        {
            return 0;
        }
        
        // perfectSquares contain all perfect square numbers which 
        // are smaller than or equal to n.
        vector<int> perfectSquares;
        // cntPerfectSquares[i - 1] = the least number of perfect 
        // square numbers which sum to i.
        vector<int> cntPerfectSquares(n);
        
        // Get all the perfect square numbers which are smaller than 
        // or equal to n.
        for (int i = 1; i*i <= n; i++)
        {
            perfectSquares.push_back(i*i);
            cntPerfectSquares[i*i - 1] = 1;
        }
        
        // If n is a perfect square number, return 1 immediately.
        if (perfectSquares.back() == n)
        {
            return 1;
        }
        
        // Consider a graph which consists of number 0, 1,...,n as
        // its nodes. Node j is connected to node i via an edge if  
        // and only if either j = i + (a perfect square number) or 
        // i = j + (a perfect square number). Starting from node 0, 
        // do the breadth-first search. If we reach node n at step 
        // m, then the least number of perfect square numbers which 
        // sum to n is m. Here since we have already obtained the 
        // perfect square numbers, we have actually finished the 
        // search at step 1.
        queue<int> searchQ;
        for (auto& i : perfectSquares)
        {
            searchQ.push(i);
        }
        
        int currCntPerfectSquares = 1;
        while (!searchQ.empty())
        {
            currCntPerfectSquares++;
            
            int searchQSize = searchQ.size();
            for (int i = 0; i < searchQSize; i++)
            {
                int tmp = searchQ.front();
                // Check the neighbors of node tmp which are the sum 
                // of tmp and a perfect square number.
                for (auto& j : perfectSquares)
                {
                    if (tmp + j == n)
                    {
                        // We have reached node n.
                        return currCntPerfectSquares;
                    }
                    else if ((tmp + j < n) && (cntPerfectSquares[tmp + j - 1] == 0))
                    {
                        // If cntPerfectSquares[tmp + j - 1] > 0, this is not 
                        // the first time that we visit this node and we should 
                        // skip the node (tmp + j).
                        cntPerfectSquares[tmp + j - 1] = currCntPerfectSquares;
                        searchQ.push(tmp + j);
                    }
                    else if (tmp + j > n)
                    {
                        // We don't need to consider the nodes which are greater ]
                        // than n.
                        break;
                    }
                }
                
                searchQ.pop();
            }
        }
        
        return 0;
}
}



282. Expression Add Operators
method:backtrack
class Solution {
public:
    vector<string> addOperators(string num, int target) {
        vector<string> ress;
        addOpe(ress,"",num,target,0,0,0);
        return ress;
        
    }
    void addOpe(vector<string> &ress,string res,string num,int target,int begin,long result,long multid)
    {
        if(begin==num.size())
        {
            if(target==result)
            ress.push_back(res);
            return ;
        }
        for(int i=begin;i<num.size();i++)
        {
            if(i!=begin&&num[begin]=='0') break;//1*05 is not right
            string str=num.substr(begin,i-begin+1);
            long cur=atol(num.substr(begin,i-begin+1).c_str());//to long INT_MIN will flow over
            if(begin==0)
            {
                addOpe(ress,res+str,num,target,i+1,cur,cur);
            }
            else
            {
                addOpe(ress,res+"+"+str,num,target,i+1,result+cur,cur);
                addOpe(ress,res+"-"+str,num,target,i+1,result-cur,-cur);
                addOpe(ress,res+"*"+str,num,target,i+1,result-multid+multid*cur,multid*cur);
            }
        }
        
    }
};




284. Peeking Iterator
method£º
// Below is the interface for Iterator, which is already defined for you.
// **DO NOT** modify the interface for Iterator.
class Iterator {
    struct Data;
	Data* data;
public:
	Iterator(const vector<int>& nums);
	Iterator(const Iterator& iter);
	virtual ~Iterator();
	// Returns the next element in the iteration.
	int next();
	// Returns true if the iteration has more elements.
	bool hasNext() const;
};


class PeekingIterator : public Iterator {
public:
	PeekingIterator(const vector<int>& nums) : Iterator(nums) {
	    // Initialize any member here.
	    // **DO NOT** save a copy of nums and manipulate it directly.
	    // You should only use the Iterator interface methods.
	    
	    
	}

    // Returns the next element in the iteration without advancing the iterator.
	int peek() {
        return Iterator(*this).next();
	}

	// hasNext() and next() should behave the same as in the Iterator interface.
	// Override them if needed.
	int next() {
	    return Iterator::next();
	}

	bool hasNext() const {
	    return Iterator::hasNext();
	}
};





287. Find the Duplicate Number
method 1:binary search
Let's say n=10 and I select mid=5. Then I count all the numbers in the array which are less than equal mid. If the there are more than 5 numbers that are less than 5, then by Pigeonhole Principle (https://en.wikipedia.org/wiki/Pigeonhole_principle) one of them has occurred more than once. So I shrink the search space from [1 10] to [1 5]. Otherwise the duplicate number is in the second half so for the next step the search space would be [6 10].

class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int low=1,high=nums.size()-1;//1~n
        while(low<high)
        {
            int count=0;
            int mid=(low+high)/2;
            for(int i:nums)
            {
                if(i<=mid) count++;
            }
            if(count<=mid)
            low=mid+1;
            else
            high=mid;
        }
        return low;
    }
};

method 2:two pionters

The main idea is the same with problem Linked List Cycle II,https://leetcode.com/problems/linked-list-cycle-ii/. Use two pointers the fast and the slow. The fast one goes forward two steps each time, while the slow one goes only step each time. They must meet the same item when slow==fast. In fact, they meet in a circle, the duplicate number must be the entry point of the circle when visiting the array from nums[0]. Next we just need to find the entry point. We use a point(we can use the fast one before) to visit form begining with one step each time, do the same job to slow. When fast==slow, they meet at the entry point of the circle. 

int findDuplicate3(vector<int>& nums)
{
	if (nums.size() > 1)
	{
		int slow = nums[0];
		int fast = nums[nums[0]];
		while (slow != fast)
		{
			slow = nums[slow];
			fast = nums[nums[fast]];
		}

		fast = 0;
		while (fast != slow)
		{
			fast = nums[fast];
			slow = nums[slow];
		}
		return slow;
	}
	return -1;
}


290. Word Pattern
my method: hashtable
class Solution {
public:
    bool wordPattern(string pattern, string str) {
        map<char,int> hs1;
        map<string,int> hs2;
        for(int i=0;i<pattern.size();i++)
        {
            int pos=str.find_first_of(" ");
            string s=str.substr(0,pos);//the second parameter is the length of s
            if(i==pattern.size()-1)
            str.erase(0,pos);
            else
            str.erase(0,pos+1);//the second parameter is the length
            if(hs1[pattern[i]]!=hs2[s])
            return false;
            hs1[pattern[i]]=i+1;
            hs2[s]=i+1;
        }
        //cout<<str.size();
        if(str.size()!=0)
        return false;
        return true;
    }
};



297. Serialize and Deserialize Binary Tree
method :pre order
class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
       if (root == nullptr) return "#";
       string res=to_string(root->val)+","+serialize(root->left)+","+serialize(root->right);
       return res;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
       return mydeserialize(data);
    }
     TreeNode* mydeserialize(string& data) {
        if (data[0]=='#') {
            if(data.size() > 1) data = data.substr(2);
            return nullptr;
        } else {
            TreeNode* node = new TreeNode(helper(data));
            node->left = mydeserialize(data);
            node->right = mydeserialize(data);
            return node;
        }
    }
private:
    int helper(string& data) {
        int pos = data.find(',');
        int val = stoi(data.substr(0,pos));
        data = data.substr(pos+1);
        return val;
    }
};

// Your Codec object will be instantiated and called as such:
// Codec codec;
// codec.deserialize(codec.serialize(root));




299. Bulls and Cows
my method:hashtable
class Solution {
public:
    string getHint(string secret, string guess) {
        map<char,int> hss,hsg;
        int anum=0,bnum=0;
        for(int i=0;i<secret.size();i++)
        {
           if(secret[i]==guess[i])
             anum++;
           else
           {
                hss[secret[i]]++;
                hsg[guess[i]]++;
           }
        }
        for(pair<char,int> p:hss)
        {
            bnum+=min(p.second,hsg[p.first]);
        }
        return to_string(anum)+"A"+to_string(bnum)+"B";
    }
};



300. Longest Increasing Subsequence
my method:o(n*n) time
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n=nums.size(),i=0,maxdp=1;
        if(n==0) return 0;
        vector<int> dp(n,1);
        while(i+1<n&&nums[i+1]<=nums[i]) i++;
        i++;
        //cout<<i;
        while(i<n)
        {
            for(int j=i-1;j>=0;j--)
            {
                if(nums[j]<nums[i])
                {
                    dp[i]=max(dp[i],dp[j]+1);
                }
            }
            maxdp=max(maxdp,dp[i]);
            i++;
        }
        //cout<<dp[0];
        return maxdp;
    }
};

method 2: O(n log n) time

tails(there is res) is an array storing the smallest tail of all increasing subsequences with length i+1 in tails[i].
For example, say we have nums = [4,5,6,3], then all the available increasing subsequences are:

len = 1   :      [4], [5], [6], [3]   => tails[0] = 3
len = 2   :      [4, 5], [5, 6]       => tails[1] = 5
len = 3   :      [4, 5, 6]            => tails[2] = 6
We can easily prove that tails is a increasing array. Therefore it is possible to do a binary search in tails array to find the one needs update.

Each time we only do one of the two:

(1) if x is larger than all tails, append it, increase the size by 1
(2) if tails[i-1] < x <= tails[i], update tails[i]

class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> res;
        for(int i=0; i<nums.size(); i++) 
        {
        auto it = lower_bound(res.begin(), res.end(), nums[i]);
        if(it==res.end()) res.push_back(nums[i]);
        else *it = nums[i]; //Í¬Ò»žöÎ»ÖÃµÄ»»³ÉžüÐ¡µÄÊý
        }
        return res.size();
    }
};



303. Range Sum Query - Immutable
my method:dp;Ê¡¿ÕŒäµÄ×ö·š£ºÖ±œÓŒÓÔÚÔ­Êý×éÉÏ
class NumArray {
    private:
    vector<int> nums;
    vector<int> dp;
public:
    NumArray(vector<int> &nums) {
        this->nums=nums;
        if(nums.size()!=0)
        {
        dp.resize(nums.size());
        dp[0]=nums[0];
        for(int i=1;i<nums.size();i++)
        {
            dp[i]=dp[i-1]+nums[i];
        }
        }
    }

    int sumRange(int i, int j) {
        if(nums.size()==0) return 0; 
        if(i==0) return dp[j];
        return dp[j]-dp[i-1];
    }
};


// Your NumArray object will be instantiated and called as such:
// NumArray numArray(nums);
// numArray.sumRange(0, 1);
// numArray.sumRange(1, 2);



304. Range Sum Query 2D - Immutable
my method:dp
class NumMatrix {
private:
    vector<vector<int>> matrix;
public:
    NumMatrix(vector<vector<int>> &matrix) {
        if(matrix.size()!=0)
        {
        for(int i=0;i<matrix.size();i++)
        for(int j=1;j<matrix[i].size();j++)
        {
            matrix[i][j]=matrix[i][j-1]+matrix[i][j];
        }
        for(int i=0;i<matrix[0].size();i++)
        for(int j=1;j<matrix.size();j++)
        {
            matrix[j][i]=matrix[j-1][i]+matrix[j][i];
        }
        }
        this->matrix=matrix;
    }

    int sumRegion(int row1, int col1, int row2, int col2) {
        if(matrix.size()==0) return 0;
        if(row1==0&&col1==0) return matrix[row2][col2];
        if(row1==0) return matrix[row2][col2]-matrix[row2][col1-1];
        if(col1==0) return matrix[row2][col2]-matrix[row1-1][col2];
        return matrix[row2][col2]-matrix[row2][col1-1]-matrix[row1-1][col2]+matrix[row1-1][col1-1];
    }
};


// Your NumMatrix object will be instantiated and called as such:
// NumMatrix numMatrix(matrix);
// numMatrix.sumRegion(0, 1, 2, 3);
// numMatrix.sumRegion(1, 2, 3, 4);



306. Additive Number
method:Choose first two number then recursively check. notice:rewrite add method handle overflow for very large input integers
class Solution {
public:
    bool isAdditiveNumber(string num) {
        for(int i=1;i<num.size();i++)
        for(int j=1;j<num.size()-i;j++)
        {
            if(check(num.substr(0,i),num.substr(i,j),num.substr(i+j))) return true;
            
        }
        return false;
    }
    bool check(string num1,string num2,string num)
    {
        if((num1.size()>1&&num1[0]=='0')||(num2.size()>1&&num2[0]=='0')) return false;
        string sum=add(num1,num2);
        if(num==sum) return true;
        if(num.size()<sum.size()||num.substr(0,sum.size())!=sum) return false;
        return check(num2,sum,num.substr(sum.size()));
    }
    string add(string a,string b)
    {
        string res;
        int i=a.size()-1,j=b.size()-1,carry=0;
        while(i>=0||j>=0)
        {
            int num=(i>=0?a[i--]-'0':0)+(j>=0?b[j--]-'0':0)+carry;
            carry=num/10;
            res.push_back(num%10+'0');
        }
        if(carry!=0) res.push_back(carry+'0');
        reverse(res.begin(),res.end());
        return res;
    }
};




307. Range Sum Query - Mutable
method:Ê÷×ŽÊý×é£»ÆäÓà»¹ÓÐÏß¶ÎÊ÷ºÍ¶þ²æÏßË÷Ê÷ÁœÖÖœâ·š
Ê÷×ŽÊý×é£ºhttp://blog.csdn.net/xyt8023y/article/details/49946789
class NumArray {
    private:
    vector<int> c;
    vector<int> m_nums;
public:
    NumArray(vector<int> &nums) {
        c.resize(nums.size() + 1);
        m_nums = nums;
        for (int i = 0; i < nums.size(); i++){
            add(i + 1, nums[i]);
        }
    }

    int lowbit(int pos){
        return pos&(-pos);
    }

    void add(int pos, int value){
        while (pos < c.size()){
            c[pos] += value;
            pos += lowbit(pos);
        }
    }
    int sum(int pos){
        int res = 0;
        while (pos > 0){
            res += c[pos];
            pos -= lowbit(pos);
        }
        return res;
    }

    void update(int i, int val) {
        int ori = m_nums[i];
        int delta = val - ori;
        m_nums[i] = val;
        add(i + 1, delta);
    }

    int sumRange(int i, int j) {
        return sum(j + 1) - sum(i);
    }
};


// Your NumArray object will be instantiated and called as such:
// NumArray numArray(nums);
// numArray.sumRange(0, 1);
// numArray.update(1, 10);
// numArray.sumRange(1, 2);



309. Best Time to Buy and Sell Stock with Cooldown
method :DP
The series of problems are typical dp. The key for dp is to find the variables to represent the states and deduce the transition function.

Of course one may come up with a O(1) space solution directly, but I think it is better to be generous when you think and be greedy when you implement.

The natural states for this problem is the 3 possible transactions : buy, sell, rest. Here rest means no transaction on that day (aka cooldown).

Then the transaction sequences can end with any of these three states.

For each of them we make an array, buy[n], sell[n] and rest[n].

buy[i] means before day i what is the maxProfit for any sequence end with buy.

sell[i] means before day i what is the maxProfit for any sequence end with sell.

rest[i] means before day i what is the maxProfit for any sequence end with rest.

Then we want to deduce the transition functions for buy sell and rest. By definition we have:

buy[i]  = max(rest[i-1]-price, buy[i-1]) 
sell[i] = max(buy[i-1]+price, sell[i-1])
rest[i] = max(sell[i-1], buy[i-1], rest[i-1])
Where price is the price of day i. All of these are very straightforward. They simply represents :

(1) We have to `rest` before we `buy` and 
(2) we have to `buy` before we `sell`
One tricky point is how do you make sure you sell before you buy, since from the equations it seems that [buy, rest, buy] is entirely possible.

Well, the answer lies within the fact that buy[i] <= rest[i] which means rest[i] = max(sell[i-1], rest[i-1]). That made sure [buy, rest, buy] is never occurred.

A further observation is that and rest[i] <= sell[i] is also true therefore

rest[i] = sell[i-1]
Substitute this in to buy[i] we now have 2 functions instead of 3:

buy[i] = max(sell[i-2]-price, buy[i-1])
sell[i] = max(buy[i-1]+price, sell[i-1])
This is better than 3, but

we can do even better

Since states of day i relies only on i-1 and i-2 we can reduce the O(n) space to O(1). And here we are at our final solution
class Solution {
public:
    int maxProfit(vector<int>& prices) {
    int buy(INT_MIN), sell(0), prev_sell(0), prev_buy;
    for (int price : prices) {
        prev_buy = buy;
        buy = max(prev_sell - price, buy);
        prev_sell = sell;
        sell = max(prev_buy + price, sell);
    }
    return sell;
    }
};



312. Burst Balloons
method:DP;devide and conquer;(not really understand)
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int inums[nums.size() + 2];
        int n = 1;
        for (int x : nums) if (x > 0) inums[n++] = x;
        inums[0] = inums[n++] = 1;
        

        int dp[n][n] = {};
        for (int k = 2; k < n; ++k) 
        for (int left = 0; left < n - k; ++left)
        {
            int right = left + k;
            for (int i = left + 1; i < right; ++i)
                dp[left][right] = max(dp[left][right],inums[left] * inums[i] * inums[right] + dp[left][i] + dp[i][right]);
        }
        

        return dp[0][n - 1];
    }
};



313. Super Ugly Number
my method:dp;the same to  ugly number II
class Solution {
public:
    int nthSuperUglyNumber(int n, vector<int>& primes) {
        vector<int> res(n,1);
        int m=primes.size();
        vector<int> count(m,0);
        
        for(int i=1;i<n;i++)
        {
            //priority_queue<int,vector<int>,less<int> > q;
            int mintmp=INT_MAX,counttmp=0;
            for(int j=0;j<m;j++)
            {
                if(res[count[j]]*primes[j]<mintmp)
                {
                    mintmp=res[count[j]]*primes[j];
                }
            }
            res[i]=mintmp;
            for(int j=0;j<m;j++)//ÓÐÖØžŽµÄ ËùÒÔÃ¿žöÐèÒªŒì²é
            {
                if(res[count[j]]*primes[j]==res[i])
                count[j]++;
            }
        }
        return res[n-1];
        
    }
};





318. Maximum Product of Word Lengths
my method:bit manipulation
class Solution {
public:
    int maxProduct(vector<string>& words) {
        int maxres=0;
        vector<int> res;
        for(int i=0;i<words.size();i++)
        {
            int tmp=0;
            for(int j=0;j<words[i].size();j++)
            {
                int selected=words[i][j]-'a';
                //cout<<selected;
                if(!((tmp>>selected)&1)) //(tmp>>selected)&1==0ÐŽ·šÊÇŽíµÄ£¿£¿
                {
                tmp^=(1<<selected);
                }
                //cout<<tmp^1;
            }
            
            res.push_back(tmp);
        }
        for(int i=0;i<words.size();i++)
        for(int j=i+1;j<words.size();j++)
        {
            int tmp=(words[i].size())*(words[j].size());
            if(!(res[i]&res[j])) maxres=max(maxres,tmp);
        }
        return maxres;
    }
};



319. Bulb Switcher
method£ºmath
A bulb ends up on iff it is switched an odd number of times.

Call them bulb 1 to bulb n. Bulb i is switched in round d if and only if d divides i. So bulb i ends up on if and only if it has an odd number of divisors.

Divisors come in pairs, like i=12 has divisors 1 and 12, 2 and 6, and 3 and 4. Except when i is a square, like 36 has divisors 1 and 36, 2 and 18, 3 and 12, 4 and 9, and double divisor 6. So bulb i ends up on if and only if i is a square.

So just count the square numbers.

Let R = int(sqrt(n)). That's the root of the largest square in the range [1,n]. And 1 is the smallest root. So you have the roots from 1 to R, that's R roots. Which correspond to the R squares. So int(sqrt(n)) is the answer. (C++ does the conversion to int automatically, because of the specified return type).

class Solution {
public:
    int bulbSwitch(int n) {
        return sqrt(n);
    }
};



321. Create Maximum Number
method:dp
To create max number of length k from two arrays, you need to create max number of length i from array one and max number of length k-i from array two, then combine them together. After trying all possible i, you will get the max number created from two arrays.

Optimization:

1.Suppose nums1 = [3, 4, 6, 5], nums2 = [9, 1, 2, 5, 8, 3], the maximum number you can create from nums1 is [6, 5] with length 2. For nums2, it's [9, 8, 3] with length 3. Merging the two sequence, we have [9, 8, 6, 5, 3], which is the max number we can create from two arrays without length constraint. If the required length k<=5, we can simply trim the result to required length from front. For instance, if k=3, then [9, 8, 6] is the result.

2.Suppose we need to create max number with length 2 from num = [4, 5, 3, 2, 1, 6, 0, 8]. The simple way is to use a stack, first we push 4 and have stack [4], then comes 5 > 4, we pop 4 and push 5, stack becomes [5], 3 < 5, we push 3, stack becomes [5, 3]. Now we have the required length 2, but we need to keep going through the array in case a larger number comes, 2 < 3, we discard it instead of pushing it because the stack already grows to required size 2. 1 < 3, we discard it. 6 > 3, we pop 3, since 6 > 5 and there are still elements left, we can continue to pop 5 and push 6, the stack becomes [6], since 0 < 6, we push 0, the stack becomes [6, 0], the stack grows to required length again. Since 8 > 0, we pop 0, although 8 > 6, we can't continue to pop 6 since there is only one number, which is 8, left, if we pop 6 and push 8, we can't get to length 2, so we push 8 directly, the stack becomes [6, 8].

3.In the basic idea, we mentioned trying all possible length i. If we create max number for different i from scratch each time, that would be a waste of time. Suppose num = [4, 9, 3, 2, 1, 8, 7, 6], we need to create max number with length from 1 to 8. For i==8, result is the original array. For i==7, we need to drop 1 number from array, since 9 > 4, we drop 4, the result is [9, 3, 2, 1, 8, 7, 6]. For i==6, we need to drop 1 more number, 3 < 9, skip, 2 < 3, skip, 1 < 2, skip, 8 > 1, we drop 1, the result is [9, 3, 2, 8, 7, 6]. For i==5, we need to drop 1 more, but this time, we needn't check from beginning, during last scan, we already know [9, 3, 2] is monotonically non-increasing, so we check 8 directly, since 8 > 2, we drop 2, the result is [9, 3, 8, 7, 6]. For i==4, we start with 8, 8 > 3, we drop 3, the result is [9, 8, 7, 6]. For i==3, we start with 8, 8 < 9, skip, 7 < 8, skip, 6 < 7, skip, by now, we've got maximum number we can create from num without length constraint. So from now on, we can drop a number from the end each time. The result is [9, 8, 7], For i==2, we drop last number 7 and have [9, 8]. For i==1, we drop last number 8 and have [9].


class Solution {
public:
    #define MIN(a,b) (a<b?a:b)
    #define MAX(a,b) (a>b?a:b)
    // create max number of length t from single non-empty vector
    void getMax(int* num, int& len, int* result, int& t, int& sortedLen)
    {
    	int n, top = 0;
    	result[0] = num[0];
    	const int need2drop = len - t;
    	for (int i = 1; i < len; ++i){
    		n = num[i];
    		while (top >= 0 && result[top] < n && (i - top) <= need2drop) --top; // i - top means already dropped i - top numbers
    		if (i - top > need2drop){
    			sortedLen = MAX(1,top);
    			while (++top < t) result[top] = num[i++];
    			return;
    		}
    		if (++top < t) result[top] = n;
    		else top = t - 1;
    	}
    }
    // create max number of different length from single vector
    void dp(int *num, int len, int&sortedLen, int& minL, int& maxL, int *res, int &k){
    	int  j, *head, *prevhead = res;
    	const int soi = sizeof(int);
    	getMax(num, len, res, maxL,sortedLen);
    	for (int l = maxL; l > MAX(minL,1); --l){
    		head = prevhead + k;
    		memcpy(head, prevhead, l*soi);
    		for (j = sortedLen; j < l; ++j){
    			if (head[j] > head[j - 1]){
    				sortedLen = MAX(1, j - 1);
    				memcpy(head + j - 1, prevhead + j, soi*(l - j));
    				break;
    			}
    		}
    		if (j == l) sortedLen = l;
    		prevhead = head;
    	}
    }
    // merge max number created from single vector
    void merge(int* num1,int len1,int* num2,int len2,int* result,int& resSize){
    	int i = 0, j = 0, k = 0;
    	while (i < resSize){
    		if (j < len1 && k < len2){
    			if (num1[j] > num2[k])
    				result[i++] = num1[j++];
    			else if (num1[j] < num2[k])
    				result[i++] = num2[k++];
    			else{
    				int remaining1 = len1 - j, remaining2 = len2 - k, tmp = num1[j];
    				int flag = memcmp(num1 + j, num2 + k, sizeof(int) * MIN(remaining1, remaining2));
    				flag = (flag == 0 ? (remaining1>remaining2 ? 1 : -1) : flag);
    				int * num = flag > 0 ? num1 : num2;
    				int & cnt = flag > 0 ? j : k;
    				int len = flag > 0 ? len1 : len2;
    				while (num[cnt]==tmp && cnt < len && i<resSize) result[i++] = num[cnt++];
    			}
    		}
    		else if (j < len1) result[i++] = num1[j++];
    		else result[i++] = num2[k++];
    	}
    }
    
    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k){
    	int soi = sizeof(int), len1 = nums1.size(), len2 = nums2.size(), step = k*soi;
    	int minL1 = MAX(0, k - len2), maxL1 = MIN(k, len1), minL2 = k - maxL1, maxL2 = k - minL1, range = maxL1 - minL1 + 1;
    	int * res = new int[range * k * 2 + 2 * k], *dp1 = res + k, *dp2 = res + range*k+k, *tmp=res+range*2*k+k;
    	memset(res, 0, step);
    	int sortedLen1 = 1, sortedLen2 = 1;
    	if (len1 == 0 && len2 > 0) getMax(&nums2[0], len2, res, k, sortedLen2);
    	else if (len1 > 0 && len2 == 0) getMax(&nums1[0], len1, res, k, sortedLen2);
    	else if (len1 > 0 && len2 > 0){
    		dp(&nums1[0], len1, sortedLen1, minL1, maxL1, dp1,k);
    		dp(&nums2[0], len2, sortedLen2, minL2, maxL2, dp2,k);
    		if (sortedLen1 + sortedLen2 > k){
    			merge(dp1 + k*(maxL1 - sortedLen1), sortedLen1, dp2 + k*(maxL2 - sortedLen2), sortedLen2, tmp, k);
    			vector<int> resv(tmp, tmp + k);
    			delete[] res;
    			return resv;
    		}
    		for (int i = minL1; i <= maxL1; ++i){
    			merge(dp1+k*(maxL1-i), i, dp2+k*(maxL2-k+i), (k-i), tmp,k);
    			if (memcmp(res, tmp, step) < 0) memcpy(res, tmp, step);
    		}
    	}
    	vector<int> resv(res, res + k);
    	delete[] res;
    	return resv;
    }
};




322. Coin Change
method:dp;set the amount as the dp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        
        vector<int> dp(amount+1,INT_MAX);
        dp[0]=0;
        for(int i=1;i<=amount;i++)
        for(int j=0;j<coins.size();j++)
        {
            if(coins[j]<=i&&dp[i-coins[j]]!=INT_MAX)
            dp[i]=min(dp[i],dp[i-coins[j]]+1);
        }
        if(dp[amount]==INT_MAX) return -1;
        else return dp[amount];
        
    }
};




324. Wiggle Sort II
method:find the median,then use virtual index;o(n) time o(1) space;another method:o(nlogn) time ,sort first,then insert 
Index :       0   1   2   3   4   5
Small half:   M       S       S    
Large half:       L       L       M


class Solution {
public:
    void wiggleSort(vector<int>& nums) {
        //find the median
        int n=nums.size();
        nth_element(nums.begin(),nums.begin()+n/2,nums.end());
        int median=nums[n/2];
         
        #define A(i) nums[(1+2*(i)) % (n|1)]
        int left = 0, i = 0, right = n - 1;

        while (i <= right) {

            if (A(i) > median) 
            {
                swap(A(left++), A(i++));
            }
            else if (A(i) < median) 
            {
                swap(A(right--), A(i));
            }
            else 
            {
                i++;
            }
        }
        
    }
};




324.
Step I -- Think naively

At first glance, the problem exhibits the feature of "optimal substructure": if we want to "rob" maximum amount of money from current binary tree (rooted at "root"), we surely hope that we can do the same to its left and right subtrees.

So going along this line, let's define the function rob(root) which will return the maximum amount of money that we can rob for the binary tree rooted at "root"; the key now is to construct the solution to the original problem from solutions to its subproblems, i.e., how to get rob(root) from rob(root.left), rob(root.right), ... etc.

Apparently the analyses above suggest a recursive solution. And for recursion, it's always worthwhile to figure out the following two properties:

Termination condition: when do we know the answer to rob(root) without any calculation? Of course when the tree is empty -- we've got nothing to rob so the amount of money is zero.

Recurrence relation: i.e., how to get rob(root) from rob(root.left), rob(root.right), ... etc. From the point of view of the tree root, there are only two scenarios at the end: "root" is robbed or is not. If it is, due to the constraint that "we cannot rob any two directly-linked houses", the next level of subtrees that are available would be the four "grandchild-subtrees" (root.left.left, root.left.right, root.right.left, root.right.right). However if root is not robbed, the next level of available subtrees would just be the two "child-subtrees" (root.left, root.right). We only need to choose the scenario which yields the larger amount of money.

Here is the program for the ideas above:

class Solution {
public:
    int rob(TreeNode* root) {
        map<TreeNode*,int> hs;
        return robSub(root,hs);
        
    }
    int robSub(TreeNode* root,map<TreeNode*,int> hs)
    {
        if(root==NULL) return 0;
        if(hs.find(root)!=hs.end()) return hs[root];
        int val=0;
        if(root->left) val+=robSub(root->left->left,hs)+robSub(root->left->right,hs);
        if(root->right) val+=robSub(root->right->left,hs)+robSub(root->right->right,hs);
        val=max(val+root->val,robSub(root->left,hs)+robSub(root->right,hs));
        hs[root]=val;
        return val;
    }
};

However the solution runs very slow (1186 ms) and barely got accepted.

Step II -- Think one step further

In step I, we only considered the aspect of "optimal substructure", but think little about the possibilities of overlapping of the subproblems. For example, to obtain rob(root), we need rob(root.left), rob(root.right), rob(root.left.left), rob(root.left.right), rob(root.right.left), rob(root.right.right); but to get rob(root.left), we also need rob(root.left.left), rob(root.left.right), similarly for rob(root.right). The naive solution above computed these subproblems repeatedly, which resulted in bad time performance. Now if you recall the two conditions for dynamic programming: "optimal substructure" + "overlapping of subproblems", we actually have a DP problem. A naive way to implement DP here is to use a hash map to record the results for visited subtrees.

And here is the improved solution:

class Solution {
public:
    int rob(TreeNode* root) {
        map<TreeNode*,int> hs;
        return robSub(root,hs);
        
    }
    int robSub(TreeNode* root,map<TreeNode*,int> hs)
    {
        if(root==NULL) return 0;
        if(hs.find(root)!=hs.end()) return hs[root];
        int val=0;
        if(root->left) val+=robSub(root->left->left,hs)+robSub(root->left->right,hs);
        if(root->right) val+=robSub(root->right->left,hs)+robSub(root->right->right,hs);
        val=max(val+root->val,robSub(root->left,hs)+robSub(root->right,hs));
        hs[root]=val;
        return val;
    }
};

The runtime is sharply reduced to 9ms, at the expense of O(n) space cost (n is the total number of nodes; stack cost for recursion is not counted).

Step III -- Think one step back

In step I, we defined our problem as rob(root), which will yield the maximum amount of money that can be robbed of the binary tree rooted at "root". This leads to the DP problem summarized in step II.

Now let's take one step back and ask why do we have overlapping subproblems? If you trace all the way back to the beginning, you'll find the answer lies in the way how we have defined rob(root). As I mentioned, for each tree root, there are two scenarios: it is robbed or is not. rob(root) does not distinguish between these two cases, so "information is lost as the recursion goes deeper and deeper", which resulted in repeated subproblems.

If we were able to maintain the information about the two scenarios for each tree root, let's see how it plays out. Redefine rob(root) as a new function which will return an array of two elements, the first element of which denotes the maximum amount of money that can be robbed if "root" is not robbed, while the second element signifies the maximum amount of money robbed if root is robbed.

Let's relate rob(root) to rob(root.left) and rob(root.right), etc. For the 1st element of rob(root), we only need to sum up the larger elements of rob(root.left) and rob(root.right), respectively, since root is not robbed and we are free to rob the left and right subtrees. For the 2nd element of rob(root), however, we only need to add up the 1st elements of rob(root.left) and rob(root.right), respectively, plus the value robbed from "root" itself, since in this case it's guaranteed that we cannot rob the nodes of root.left and root.right.

As you can see, by keeping track of the information of both scenarios, we decoupled the subproblems and the solution essentially boiled down to a greedy one. Here is the program:

class Solution {
public:
    int rob(TreeNode* root) {
        vector<int> res=robSub(root);
        return max(res[0],res[1]);
    }
    vector<int> robSub(TreeNode* root)
    {
        if(root==NULL) return vector<int>(2,0);
        vector<int> left=robSub(root->left);
        vector<int> right=robSub(root->right);
        vector<int> res(2,0);
        res[0]=left[1]+right[1]+root->val;
        res[1]=max(left[0],left[1])+max(right[0],right[1]);
        return res;
    }
};


326. Power of Three
my method:math;loop
class Solution {
public:
    bool isPowerOfThree(int n) {
        if(n<=0) return false;
        while(n)
        {
            if(n==1) return true;
            if(n%3!=0) return false;
            n=n/3;
        }
        return true;
    
    }
};

method 2:without loop or recursive;Find the maximum integer that is a power of 3 and check if it is a multiple of the given input
µ«ÊÇÖ»ÄÜÓÃÓÚËØÊý
class Solution {
public:
    bool isPowerOfThree(int n) {
         int maxPowerOfThree = (int)pow(3, (int)(log(0x7fffffff) /log(3)));
    return n>0 && maxPowerOfThree%n==0;
    
    }
};

method 3:without loop or recursive;ÓÃLOGµÄ»»µØ¹«Êœ£ºlogm(n)=log10(n)/log10(m)ÎªÕûÊý
class Solution {
public:
    bool isPowerOfFour(int num) {
        return fmod((log10(num)/log10(3)),1)==0;//²»ÄÜÖ±œÓÓÃ%£¬%Ö»ÄÜÓÃÓÚÕûÊý£¬fmod¿ÉÓÃÓÚfloat
    }
};



334. Increasing Triplet Subsequence
my method: idea is the same the method 2 of (300.  Longest Increasing Subsequence)
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        vector<int> res;
        for(int i=0;i<nums.size();i++)
        {
            auto it=lower_bound(res.begin(),res.end(),nums[i]);
            if(it==res.end()) 
            {
                res.push_back(nums[i]);
                if(res.size()==3) return true;
            }
            else *it=nums[i];
        }
        return false;
    }
};

method 2: the same idea;but o(n) time o(1) space
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int c1=INT_MAX,c2=INT_MAX;
        for(int num:nums)
        {
            if(num<=c1) c1=num;
            else if(num<=c2) c2=num;//×¢ÒâÊÇ<=
            else return true;
        }
        return false;
    }
};




338. Counting Bits
method 1 £º
class Solution {
public:
    vector<int> countBits(int num) {
        vector<int> res;
        res.push_back(0);
        res.push_back(1);
        res.push_back(1);
        res.push_back(2);
        int begin=2;
        for(int i=4;i<=num;i++)
        {
            if(i%begin==0)
            {
                begin=begin*2;
                res.push_back(1);//it's not true:res[i]=1  unless defined as "vector<int> res(num+1);"
            }
            else
            {
                res.push_back(res[i%begin]+1);
            }
            
        }
        if(num<3)
        res.erase(res.begin()+num+1,res.end());
        //cout<<res.size()<<endl;
        return res;
    }
};

method 2:use &,ret[0]=0
class Solution {
public:
    vector<int> countBits(int num) {
        vector<int> ret(num+1, 0);
        for (int i = 1; i <= num; ++i)
            ret[i] = ret[i&(i-1)] + 1;
        return ret;
    }
};



342. Power of Four
my method:LOG
class Solution {
public:
    bool isPowerOfFour(int num) {
        return fmod((log10(num)/log10(4)),1)==0;
    }
};



343. Integer Break
my method:math
class Solution {
public:
    int integerBreak(int n) {
        if(n==2) return 1;
        if(n==3) return 2;
        if(n%3==1) return pow(3,n/3-1)*4;
        if(n%3==0) return pow(3,n/3);
        if(n%3==2) return pow(3,n/3)*2;
        return 1;
    }
};



347. Top K Frequent Elements
my method 1:hashtable then sort(can't sort map straightly);it is accepted but sort() time complexicity is nlogn ,can't meet the requirement
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        map<int,int> hs;
        for(int i=0;i<nums.size();i++)
        {
            hs[nums[i]]++;
        }
        map<int,int>::iterator it;
        vector<pair<int,int>> vec;
        for(it=hs.begin();it!=hs.end();it++)
            vec.push_back(make_pair(it->first,it->second));
        sort(vec.begin(),vec.end(),cmp);
        vector<int> res;
        int i;
        for(i=0;i<k;i++)
        {
            res.push_back(vec[i].first);
        }
        return res;
    }
    static int cmp(pair<int,int> x,pair<int,int> y)
    {
        return x.second>y.second;
    }
};

method 2:
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        map<int,int> hs;
        for(int i=0;i<nums.size();i++)
        {
            hs[nums[i]]++;
        }
        
       vector<vector<int>> vec(100,vector<int>());//must initial
       for(pair<int,int> it:hs)
       {
           int frequence=it.second;
           vec[frequence].push_back(it.first);
       }
       vector<int> res;
       for(int i=vec.size()-1;res.size()<k&&i>=0;i--)
       {
           if(res.size()>k) break;
           if(vec[i].size()!=0)
           {
               for(int j=0;j<vec[i].size()&&res.size()<k;j++)
               res.push_back(vec[i][j]);
           }
           
       }
        return res;
    }
   
};

method 3£º
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        map<int,int> hs;
        for(int i=0;i<nums.size();i++)
        {
            hs[nums[i]]++;
        }
        
        vector<int> res;
        priority_queue<pair<int,int>> q;
        for(pair<int,int> p:hs)
        {
            q.push({p.second,p.first});
            if(q.size()>hs.size()-k)
            {
                res.push_back(q.top().second);
                q.pop();
            }
        }
       
        return res;
        
    }
    
};


354. Russian Doll Envelopes
method:
Sort the array. Ascend on width and descend on height if width are same.
Find (300.the longest increasing subsequence) based on height.
Since the width is increasing, we only need to consider height.
[3, 4] cannot contains [3, 3], so we need to put [3, 4] before [3, 3] when sorting otherwise it will be counted as an increasing number if the order is [3, 3], [3, 4]

class Solution {
public:
    int maxEnvelopes(vector<pair<int, int>>& envelopes) {
        if(envelopes.size()==0) return 0;
        sort(envelopes.begin(),envelopes.end(),cmp);
        vector<int> res;
        for(auto env:envelopes)
        {
           auto it=lower_bound(res.begin(),res.end(),env.second);
           if(it==res.end()) res.push_back(env.second);
           else *it=env.second;
        }
        return res.size();
        
    }
    static bool cmp(pair<int,int> x,pair<int,int> y)
    {
        if(x.first==y.first) return x.second>y.second;
        return x.first<y.first;
    }
};



357. Count Numbers with Unique Digits
my method:DP
class Solution {
public:
    int countNumbersWithUniqueDigits(int n) {
        int res=1;
        for(int i=1;i<=n;i++)
        {
            int count=9,k=1;
            for(int j=0;j<i;j++)
            {
                if(j==1) count++;
                k*=count--;
                
            }
            res+=k;
            
        }
        return res;
        
    }
};



363. Max Sum of Rectangle No Larger Than K
method:dp;don't understand
class Solution {
public:
    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {
         if (matrix.empty()) return 0;
    int row = matrix.size(), col = matrix[0].size(), res = INT_MIN;
    for (int l = 0; l < col; ++l) 
    {
        vector<int> sums(row, 0);
        for (int r = l; r < col; ++r) 
        {
            for (int i = 0; i < row; ++i) 
            {
                sums[i] += matrix[i][r];
            }
            
            // Find the max subarray no more than K (?)
            set<int> accuSet;
            accuSet.insert(0);
            int curSum = 0, curMax = INT_MIN;
            for (int sum : sums) 
            {
                curSum += sum;
                set<int>::iterator it = accuSet.lower_bound(curSum - k);
                if (it != accuSet.end()) curMax = std::max(curMax, curSum - *it);
                accuSet.insert(curSum);
            }
            res = std::max(res, curMax);
        }
    }
    return res;
    }
};



365. Water and Jug Problem
method:math
ÕâµÀÎÊÌâÆäÊµ¿ÉÒÔ×ª»»ÎªÓÐÒ»žöºÜŽóµÄÈÝÆ÷£¬ÎÒÃÇÓÐÁœžö±­×Ó£¬ÈÝÁ¿·Ö±ðÎªxºÍy£¬ÎÊÎÒÃÇÍš¹ýÓÃÁœžö±­×ÓÍùÀïµ¹Ë®£¬ºÍÍù³öÒšË®£¬ÎÊÄÜ²»ÄÜÊ¹ÈÝÆ÷ÖÐµÄË®žÕºÃÎªzÉý¡£ÄÇÃŽÎÒÃÇ¿ÉÒÔÓÃÒ»žö¹«ÊœÀŽ±íŽï£º

z = m * x + n * y

ÆäÖÐm£¬nÎªÒšË®ºÍµ¹Ë®µÄŽÎÊý£¬ÕýÊý±íÊŸÍùÀïÒšË®£¬žºÊý±íÊŸÍùÍâµ¹Ë®£¬ÄÇÃŽÌâÄ¿ÖÐµÄÀý×Ó¿ÉÒÔÐŽ³É: 4 = (-2) * 3 + 2 * 5£¬ŒŽ3ÉýµÄË®¹ÞÍùÍâµ¹ÁËÁœŽÎË®£¬5ÉýË®¹ÞÍùÀïÒšÁËÁœŽÎË®¡£ÄÇÃŽÎÊÌâŸÍ±ä³ÉÁË¶ÔÓÚÈÎÒâžø¶šµÄx,y,z£¬Žæ²»ŽæÔÚmºÍnÊ¹µÃÉÏÃæµÄµÈÊœ³ÉÁ¢¡£žùŸÝÅáÊñ¶šÀí£¬ax + by = dµÄœâÎª d = gcd(x, y)£¬ÄÇÃŽÎÒÃÇÖ»ÒªÖ»Òªz % d == 0£¬ÉÏÃæµÄµÈÊœŸÍÓÐœâ£¬ËùÒÔÎÊÌâŸÍÓ­ÈÐ¶øœâÁË£¬ÎÒÃÇÖ»Òª¿ŽzÊÇ²»ÊÇxºÍyµÄ×îŽó¹«ÔŒÊýµÄ±¶ÊýŸÍÐÐÁË£¬±ðÍüÁË»¹ÓÐžöÏÞÖÆÌõŒþx + y >= z£¬ÒòÎªxºÍy²»¿ÉÄÜ³Æ³ö±ÈËüÃÇÖ®ºÍ»¹¶àµÄË®

BšŠzout's identity (also called BšŠzout's lemma) is a theorem in the elementary theory of numbers:

let a and b be nonzero integers and let d be their greatest common divisor. Then there exist integers x
and y such that ax+by=d

In addition, the greatest common divisor d is the smallest positive integer that can be written as ax + by

every integer of the form ax + by is a multiple of the greatest common divisor d.


class Solution {
public:
    bool canMeasureWater(int x, int y, int z) {
        if(x+y<z) return false;
        return z==0||z%gcd(x,y)==0;
    }
    int gcd(int x,int y)
    {
        return y==0?x:gcd(y,x%y);
    }
};




367. Valid Perfect Square
my method:binary search
class Solution {
public:
    bool isPerfectSquare(int num) {
        if(num==0) return true;
        int low=1,high=num;
        while(low<=high)
        {
            int mid=low+(high-low)/2;
            if(mid==num/mid) 
            {
                if(mid*mid==num) return true;
                else return false;
            }
            else if(mid>num/mid) 
            {
                high=mid-1;
            }
            else
            {
                low=mid+1;
            }
        }
        return false;
    }
};

method 2: ÍêÃÀµÄÆœ·œ=1+3+5+7+¡£¡£¡£
public boolean isPerfectSquare(int num) {
    int i = 1;
    while (num > 0) {
        num -= i;
        i += 2;
    }
    return num == 0;
}



368. Largest Divisible Subset
my method:DP
class Solution {
public:
    vector<int> largestDivisibleSubset(vector<int>& nums) {
        int n=nums.size();
        if(n==0) return {};
        
        vector<vector<int>> dp(n,vector<int>());
        sort(nums.begin(),nums.end());
        dp[0].push_back(nums[0]);
        //cout<<1;
        int finalmax=1,finalindex=0;
        for(int i=1;i<n;i++)
        {
            int maxsize=0,index=-1;
            for(int j=i-1;j>=0;j--)
            {
                if(nums[i]%nums[j]==0&&dp[j].size()>maxsize)
                {
                    index=j;
                    maxsize=dp[j].size();
                }
                
            }
            if(index!=-1)
            dp[i]=dp[index];
            dp[i].push_back(nums[i]);
            if(dp[i].size()>finalmax)
            {
                finalmax=dp[i].size();
                finalindex=i;
            }
        }
        return dp[finalindex];
    }
};
ÓÅ»¯£º²»ÐèÒªÃ¿žöœá¹û¶ŒŽæÆðÀŽ£¬¿ÉÒÔÓÃÒ»žöÊý×éŽæŽËœÚµãµÄžžœÚµã

¿ÉÒÔÓÃ¶¯Ì¬¹æ»®ÀŽœâŸö. ÎªÁËÊ¹µÃÎÊÌâ¿ÉÒÔ×ª»¯Îª×ÓÎÊÌâ, ×îºÃœ«Êý×é°ŽÕÕœµÐòÀŽÅÅÁÐ, È»ºóµ±nums[j]%nums[i]==0µÄÊ±ºòŸÍ¿ÉÒÔµÃµœÒ»žö×ŽÌ¬×ªÒÆ·œ³Ìdp[i] = max(dp[i], dp[j]+1), ÒòÎªÊý×é°ŽÕÕœµÐòÅÅÐò, ËùÒÔnums[i] < nums[j],²¢ÇÒÖ®Ç°ÄÜ¹»±»nums[j]Õû³ýµÄÊý, Ò²±ØÈ»ÄÜ¹»±ðnums[i]Õû³ý, ÕâŸÍ±£Ö€ÁË×ŽÌ¬×ªÒÆ·œ³ÌµÄÕýÈ·ÐÔ. 

Ëû»¹ÒªÇóÕÒ³ö×îŽóœá¹û, ËùÒÔÎÒÃÇ»¹ÐèÒªŒÇÂŒÒ»ÏÂÂ·Ÿ¶, Ã¿Ò»žöÊý×Ö, ÎÒÃÇŒÇÂŒÒ»žöµÚÒ»žöÄÜ¹»Ê¹ÆäµœŽï×îŽó³€¶ÈµÄžžœáµã, ×îºó»ØËÝÒ»ÏÂŒŽ¿É.

class Solution {  
public:  
    vector<int> largestDivisibleSubset(vector<int>& nums) {  
        if(nums.size() ==0) return {};   
        sort(nums.begin(), nums.end(), greater<int>());  
        int len = nums.size(), curMax=1, k=0;  
        vector<int> par(len), dp(len, 1), result;  
        for(int i =0; i < len; i++) par[i] = i;  
        for(int i =1; i < len; i++)  
        {  
            for(int j =0; j < i; j++)  
            {  
                if(nums[j]%nums[i]!=0) continue;  
                if(dp[i] < dp[j]+1) par[i] = j, dp[i]=dp[j]+1;  
                if(dp[i] > curMax) curMax = dp[i], k = i;  
            }  
        }  
        while(par[k] != k)  
        {  
            result.push_back(nums[k]);  
            k = par[k];  
        }  
        result.push_back(nums[k]);  
        return result;  
    }  
};  



372. Super Pow
method:math
One knowledge: ab % k = (a%k)(b%k)%k
Since the power here is an array, we'd better handle it digit by digit.
One observation:
a^1234567 % k = (a^1234560 % k) * (a^7 % k) % k = (a^123456 % k)^10 % k * (a^7 % k) % k
Looks complicated? Let me put it other way:
Suppose f(a, b) calculates a^b % k; Then translate above formula to using f :
f(a,1234567) = f(a, 1234560) * f(a, 7) % k = f(f(a, 123456),10) * f(a,7)%k;

class Solution {
public:
    int superPow(int a, vector<int>& b) {
        if (b.empty()) return 1;
        int last_digit = b.back();
        b.pop_back();
        return powmod(superPow(a, b), 10) * powmod(a, last_digit) % 1337;
    }
    
    int powmod(int a,int k)
    {
        a=a%1337;
        int result=1;
        for(int i=0;i<k;i++)
        result=(result*a)%1337;
        return result;
    }
};




374. Guess Number Higher or Lower
my method:binary search
// Forward declaration of guess API.
// @param num, your guess
// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
int guess(int num);

class Solution {
public:
    int guessNumber(int n) {
        return guessnum(1,n);
    }
    int guessnum(int low,int high)
    {
        if(low>high) return -1;
        int mid=low+(high-low)/2;//mid=(low+high)/2 lead to runtime error
        if(guess(mid)==0) return mid;
        else if(guess(mid)==-1) return guessnum(low,mid-1);
        else return guessnum(mid+1,high);
    }
};



375. Guess Number Higher or Lower II
method:DP
For each number x in range[i~j]
we do: result_when_pick_x = x + max{DP([i~x-1]), DP([x+1, j])}
--> // the max means whenever you choose a number, the feedback is always bad and therefore leads you to a worse branch.
then we get DP([i~j]) = min{xi, ... ,xj}
--> // this min makes sure that you are minimizing your cost.

class Solution {
public:
    int getMoneyAmount(int n) {
        vector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));
        for (int i = 1; i <= n; ++i){
            for (int j = i - 1; j >= 1; --j){
                int min_value = INT_MAX;
                for (int k = j; k <= i; ++k){
                    int tmp = k + max(dp[j][k - 1], dp[k + 1][i]);
                    min_value = min(min_value, tmp);
                }
                dp[j][i] = min_value;
            }
        }
        return dp[1][n];
       
    }
    
};




376. Wiggle Subsequence
my method:
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if(nums.size()==0) return 0;
        if(nums.size()==1) return 1;
        int count=1,state=0,j=0;
        while(j+1<nums.size()&&nums[j]==nums[j+1]) j++;
        if(j==nums.size()-1)  return 1;// all is one number
        if(nums[j+1]>nums[j]) state=1;
        for(int i=j;i<nums.size();i++)
        {
            if(state&&nums[i]>nums[i-1])
            {
                count++;
                state=0;
            }
            if(!state&&nums[i]<nums[i-1])
            {
                count++;
                state=1;
            }
        }
        return count;
    }
};



377. Combination Sum IV
my method:DP;similar to 70.Climbing Stairs
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        if(nums.size()==0) return 0;
        sort(nums.begin(),nums.end());
        vector<int> sum(target+1,0);
        for(int i=nums[0];i<=target;i++)
        {
            sum[i]=0;
            for(int j=0;j<nums.size();j++)
            {
                if(i-nums[j]<0) break;
                if(i-nums[j]==0) sum[i]+=1;
                sum[i]+=sum[i-nums[j]];
                
            }
        }
        return sum[target];
    }
};



382. Linked List Random Node
method:
ÄÇÃŽÈçºÎÈ·±£¶ÔÓÚÃ¿žöÔªËØ¶ŒÓÐÏàµÈµÄžÅÂÊÄØ? ÕâÀïÓÃµœÁËžÅÂÊÂÛµÄÖªÊ¶, ÔÚ±éÀúµœµÚižöÊýÊ±ÉèÖÃÑ¡È¡ÕâžöÊýµÄžÅÂÊÎª1/i, È»ºóÀŽÖ€Ã÷Ò»ÏÂÃ¿žöÊý±»Ñ¡µœµÄžÅÂÊ: ¶ÔÓÚµÚÒ»žöÊýÆä±»Ñ¡ÔñµÄžÅÂÊÎª1/1*(1-1/2)*(1-1/3)*(1-1/4)*...*(1-1/n) = 1/n, ÆäÖÐ(1-1/n)µÄÒâËŒÊÇ²»Ñ¡ÔñnµÄžÅÂÊ, Ò²ŸÍÊÇÑ¡Ôñ1µÄžÅÂÊ³ËÒÔ²»Ñ¡ÔñÆäËûÊýµÄžÅÂÊ. ¶ÔÓÚÈÎÒâÒ»žöÊýiÀŽËµ, Æä±»Ñ¡ÔñµÄžÅÂÊÎª1/i*(1-1/(i+1))*...*(1-1/n), ËùÒÔÔÚÃ¿Ò»žöÊýµÄÊ±ºòÎÒÃÇÖ»Òª°ŽÕÕËæ»úÒ»žöÊÇ·ñÊÇiµÄ±¶ÊýŒŽ¿ÉŸö¶šÊÇ·ñÈ¡µ±Ç°ÊýŒŽ¿É.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    private:
    ListNode *p;
public:
    /** @param head The linked list's head.
        Note that the head is guaranteed to be not null, so it contains at least one node. */
    Solution(ListNode* head) {
        p=head;
    }
    
    /** Returns a random node's value. */
    int getRandom() {
        ListNode* cur=p;
        int val=cur->val;
        for(int i=1;cur;i++)//i start from 1
        {
            if(rand()%i==0) val=cur->val;
            cur=cur->next;
        }
        return val;
    }
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(head);
 * int param_1 = obj.getRandom();
 */




383. Ransom Note
my method: hashtable
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        map<char,int> hs;
        for(char c:magazine)
           hs[c]++;
        for(char c:ransomNote)
        {
            hs[c]--;
            if(hs[c]<0)
            return false;
        }
        return true;
    }
};



384. Shuffle an Array
method:rand ÏÂ±ê£¬È»ºóœ»»»
class Solution {
    private:
    vector<int> nums;
public:
    Solution(vector<int> nums) {
        this->nums=nums;
    }
    
    /** Resets the array to its original configuration and return it. */
    vector<int> reset() {
        return nums;
    }
    
    /** Returns a random shuffling of the array. */
    vector<int> shuffle() {
        vector<int> result(nums);
        for (int i = 0;i < result.size();i++) {
            int pos = rand()%(result.size()-i);
            swap(result[i+pos], result[i]);
        }
        return result;
    }
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(nums);
 * vector<int> param_1 = obj.reset();
 * vector<int> param_2 = obj.shuffle();
 */





387. First Unique Character in a String
my method:hashtable
class Solution {
public:
    int firstUniqChar(string s) {
        map<char,int> hs;
        int len=s.size();
        for(int i=0;i<len;i++)
        {
            if(hs[s[i]]==0)
            hs[s[i]]=i+1;
            else
            hs[s[i]]=-1;
        }
        int res=len+1;
        for(pair<char,int> p:hs)
        {
            if(p.second>0)
            res=min(res,p.second);
        }
        if(res==len+1)
        res=0;
        return res-1;
        
    }
};



388. Longest Absolute File Path
method£º¡®\t¡¯is one char
class Solution {
public:
    int lengthLongestPath(string input) {
        int maxi=0,count=0,ln=1;
        bool isFile=false;
        vector<int> level(200);
        level[0]=0;
        for(int i=0,fin=input.size();i<fin;++i){
            //find which level
            while(input[i]=='\t'){
                ++ln;++i;
            }
            //read file name
            while(input[i]!='\n'&&i<fin){
                if(input[i]=='.')isFile=true;
                ++count;++i;
            }
            //calculate
            if(isFile){
                maxi=max(maxi,level[ln-1]+count);
            }
            else{
                level[ln]=level[ln-1]+count+1;// 1 means '/'
            }
            //reset
            count=0;ln=1;isFile=false;
        }
        return maxi;
    }
};



389. Find the Difference
my method:hashtable
class Solution {
public:
    char findTheDifference(string s, string t) {
        map<char,int> hs;
        for(char c:s)
        hs[c]++;
         
        for(char c:t)
        {
            hs[c]--;
            if(hs[c]<0) return c;
        }
        return ' ';
    }
};

method 2:bit
class Solution {
public:
    char findTheDifference(string s, string t) {
        char res=0;
        for(char c:s)
        res^=c;
        for(char c:t)
        res^=c;
        return res;
    }
};


392. Is Subsequence
my method: two pointers
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int i=0,j=0;
        while(i<s.size()&&j<t.size())
        {
            if(s[i]==t[j]) i++;
            j++;
        }
        return i==s.size();
    }
};



